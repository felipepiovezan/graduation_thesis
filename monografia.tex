\documentclass{ufscThesis}

\usepackage{graphicx} % Possibilita o uso de figuras e gráficos
\usepackage{epsfig}
\usepackage{color, colortbl}    % Possibilita o uso de cores no documento
\usepackage{multirow, amsmath}
\usepackage{clrscode3e}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{caption, float}
\usepackage[export]{adjustbox}
\usepackage{pdfpages}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{amssymb}



%----------------------------------------------------------------------
% Comandos criados pelo usuário
\newcommand{\ABNTbibliographyname}{REFERÊNCIAS}
\newcommand{\afazer}[1]{{\color{red}{#1}}} % Para destacar uma parte a ser trabalhada
\newcommand{\ingles}[1]{\emph{#1}}
\newcommand{\keyword}[1]{\textbf{#1}}
\newtheorem{definicao}{Definição}
\newtheorem{teorema}{Teorema}

%----------------------------------------------------------------------
% Identificadores do trabalho
% Usados para preencher os elementos pré-textuais
\instituicao[a]{Universidade Federal de Santa Catarina} % Opcional
\departamento[a]{Departamento de Informática e Estatística}
\curso[o]{Curso de Bacharelado em Ciência da Computação}
%\documento[o]{TCC} % Opcional (Tese é o padrão)
\titulo{Análise da eficiência energética de algoritmos de criptografia baseados em curvas elípticas}
%\subtitulo{} % Opcional
\autor{Felipe de Azevedo Piovezan}
\grau{Bacharel em Ciência da Computação}
\local{Florianópolis - Santa Catarina} % Opcional (Florianópolis é o padrão) % chktex 8 
\data{02}{Dezembro}{2015}
\orientador[Orientador]{Prof.\ Dr.\ Luiz Cláudio Villar dos Santos}
\coorientador[Coorientador]{Prof.\ Dr.\ Daniel Santana de Freitas}
\coordenador[Coordenador]{Prof.\ Dr.\ Renato Cislaghi}

\numerodemembrosnabanca{5} % Isso decide se haverá uma folha adicional
\orientadornabanca{sim} % Se faz parte da banca definir como sim
\coorientadornabanca{sim} % Se faz parte da banca definir como sim
\bancaMembroA{Prof.\ Dr.\ Luiz Cláudio Villar dos Santos} %Nome do presidente da banca
\bancaMembroB{Prof.\ Dr.\ José Luís Almada Güntzel}      % Nome do membro da Banca
\bancaMembroC{Prof.\ Dr.\ Daniel Santana de Freitas}     % Nome do membro da Banca
%\bancaMembroD{Quarto membro}       % Nome do membro da Banca
%\bancaMembroE{Prof. quinto membro}       % Nome do membro da Banca
%\bancaMembroF{Prof. sexto membro}        % Nome do membro da Banca
%\bancaMembroG{Prof. sétimo membro}       % Nome do membro da Banca

\agradecimento{TBC}

\epigrafe{``Nevermore''}
{The Raven}

\textoResumo{A criptografia de chaves públicas (PKC), ou criptografia assimétrica, uma das bases para a comunicação segura pela internet, fornece as primitivas para a troca de chaves, autenticação de usuários e assinatura digital. A maioria dos algoritmos de PKC usados atualmente são baseados em conjecturas de teoria dos números, como a dificuldade da fatoração de inteiros ou a dificuldade de alguma versão do logaritmo discreto. Este último, quando usado na versão de curvas elípticas, permite o uso de chaves e assinaturas menores para o mesmo nível de segurança de outros algoritmos, o que é interessante em ambientes com recursos limitados.

	Durante o desenvolvimento dos algoritmos assimétricos, os principais nodos da rede eram grandes servidores e desktops. Recentemente, porém, a escala dos dispositivos que estabelecem comunicação segura pela internet está diminuindo consistentemente: dos laptops e celulares, até sensores e etiquetas RFID, todos necessitam de um canal seguro. Essa miniaturização, no entanto, veio acompanhada de restrições de processamento e de suprimento energético, o que conflita com o fato que algoritmos de PKC são computacionalmente caros: como, então, utilizá-los em ambientes com recursos limitados? O presente trabalho pretende, a partir de simulações, avaliar o gasto energético do sistema de memórias de processadores executando algoritmos de criptografia de curvas elípticas, bem como o impacto que técnicas de otimização têm na eficiência energética.
}

\palavrasChave{Palavras chave}

\textAbstract{The realm of public-key (asymmetric) cryptography (PKC) is considered to be one the pillars of secure communication over the internet, since it includes user authentication, key enchange and digital signatures. PKC algorithms in use are mostly based in certain number-theoretic conjectures, like the difficulty of integer factorization or the difficulty of some discrete-log problem. The latter, when used in the elliptic curve setting, allows for shorter keys and signatures while maintaining the same security level of other algorithms, which is interesting in a resource constrained environment.
	
	During the development of the first asymmetric algorithms, most nodes in a network were either desktops or servers. Recently, however, the scale of the devices partaking in secure communations over the internet has been steadily decreasing: from laptops and cellphones to sensors and RFID tags, they all require a secure channel. This miniaturization is responsible for new restrictions on the processing power and battery supply available to each node, which directly conflicts with the fact that PKC algorithms are computationally expensive. What then is the best way to employ those algorithms in such restricted devices? Through the use of simulations, this work will evaluate the energy cost of the memory system of processors executing elliptic curve algorithms, as well as the impact that certain optimzation techniques have on energy efficiency. 
}
\keywords{keywords}

\begin{document}

%--------------------------------------------------------
% Elementos pré-textuais
%\capa  
\folhaderosto[comficha]
\folhaaprovacao% chktex 8 
\paginadedicatoria% chktex 8 
\paginaagradecimento% chktex 8 
\paginaepigrafe% chktex 8 
\paginaresumo% chktex 8 
\paginaabstract% chktex 8 
%\pretextuais % Substitui todos os elementos pre-textuais acima
\listadefiguras% as listas dependem da necessidade do usuário % chktex 8 
\listadetabelas% chktex 8 
\listadeabreviaturas% chktex 8 
\listadesimbolos% chktex 8 
\sumario% chktex 8 
%--------------------------------------------------------
% Elementos textuais

\chapter{Introdução}

Com a expansão da internet, não apenas servidores e \ingles{desktops} passam a fazer parte da rede, mas também um grande número de pequenos dispositivos como PDAs, celulares e sensores. Acoplados aos processores de tais equipamentos, encontram-se transmissores de rádio que permitem a comunição com outros dispositivos, estejam eles em uma rede local ou à longa distância conectados por algum \ingles{gateway}. Alguns problemas em comum podem ser encontrados nesses dispositivos, como limitações na capacidade de processamento, quantidade de memória e disponibilidade de bateria, além de estarem potencialmente expostos a diversos usuários maliciosos. O desafio, então, surge ao observar-se que a solução para a última deficiência entra diretamente em conflito com as primeiras.

Os protocolos utilizados para comunicação segura, sejam eles aqueles utilizados por browsers (como o TLS), por terminais (como o SSH) ou até mesmo em aplicações da internet das coisas (como~\cite{Resner:SENSORNETS:2015}), dependem de duas grandes classes de algoritmos criptográficos: os simétricos e os assimétricos. Embora as mensagens sejam cifradas com algoritmos simétricos, como o AES, o esbelecimento de um canal seguro é, de modo geral, iniciado com o uso da classe assimétrica, a qual permite a definição de um chave secreta conhecida apenas pelos participantes da conversa. Essa chave passa a ser utilizada pelo resto da sessão segura em algoritmos simétricos.

De modo geral, observa-se que algoritmos simétricos possuem implementações extremamente simples, podendo ser otimizados para diferentes configurações de processadores. É o caso do \ingles{Rijndael}~\cite{daemen1999aes}, vencedor da competição que elegeu o \ingles{Advanced Encryption Standard} (AES), cuja implementação pode ser feita executando-se operações matemáticas ou com o uso de \ingles{look-up tables} que variam de tamanho: 256 bytes, 1KB ou 4KB\@. Desse modo, permite-se a execução do AES em processadores com diferentes configurações de memória. Tamanha flexibilidade não ocorre por acaso: o algoritmo foi desenvolvido com esse objetivo, visto que a competição incluiu critérios como requerimento de memória, eficiência computacional e simplicidade para avaliação dos candidatos~\cite{nechvatal2000report}.

Por outro lado, os algoritmos assimétricos possuem implementações complexas pela natureza do problema que propõem: muitos deles estão associados ao uso de conjecturas da teoria dos números sob domínios de ordem muito grande, isto é, trabalham com conjuntos cuja cardinaliade precisa de centenas ou até milhares de bits para ser representada. Um dos algoritmos mais famosos dessa classe, o RSA, é baseado na dificuldade da fatoração de inteiros e trabalha com números na ordem de 1024 bits. Pode-se perceber, então, um dos possíveis inconvenientes que esse algoritmo trás: a aritmética de números desse tamanho não é trivial de ser implementada, principalmente se considerarmos que processadores utlizados em, por exemplo, redes de sensores trabalham com registradores de 8 ou 16 bits\footnote{É o caso do \ingles{Atmel ATmega} (8 bits) ou do \ingles{Texas Instruments MSP430} (16 bits)}.

Nesse cenário, as técnicas baseadas em curvas elípticas (ECC) mostraram-se muito interessantes por propiciarem um mesmo nível de seguraça para um menor tamanho de chave. De acordo com~\cite{LenstraSelectingKeys}, a equivalência entre os tamanhos de chaves para as duas técnicas pode ser resumida na tabela~\ref{tab:RSAxECC}. Pode-se notar que a diferença chega próximo de uma ordem de magnitude em muitos casos e, de fato, este é um dos argumentos utilizados pela RFC que adiciona algoritmos de ECC ao protocolo TLS~\cite{Blake-wilson06ellipticcurve}.

\begin{table}[h]
\centering
\begin{tabular}{cc}
\hline
ECC             & RSA             \\ \hline
163             & 1024            \\
233             & 2048            \\
283             & 3072            \\
409             & 7680            \\ \hline
\end{tabular}
\caption{Tamanho de chave (em bits) necessário para que os algoritmos ECC e RSA forneçam segurança equivalente~\cite{LenstraSelectingKeys}.}
\label{tab:RSAxECC}
\end{table}

Apesar dos algoritmos de ECC possibilitarem uma redução no tamanho das chaves, a implementação eficiente de criptografia de chaves públicas em ambientes com recursos limitados necessitou de muitos esforços da academia, conforme relatado por~\cite {Wenger:2013}. Tamanho investimento é justificado pelo crescente número de aplicações que executam em tais ambientes, como \ingles{smart cards}, redes de sensores sem fio ou etiquetas RFID\@. Para o caso de redes de sensores com processadores de 8 bits, apenas em 2004 demonstrou-se a viabilidade do uso de algoritmos de ECC em tais plataformas~\cite{first8bits:Gura}. De modo similar, a primeira implementação em hardware com consumo energético baixo o suficiente para ser alimentado passivamente foi demonstrada em 2008~\cite{Hein:2009}. Atualmente, diversos dispositivos médicos, como marcapasos, são configurados através de um canal sem fio e possuem longevidade de 5 a 15 anos. Nesse cenário, algoritmos de curvas elípticas são empregados por proverem a seguraça e eficiência necessárias~\cite{fan2013low}.


\section{Motivação e trabalho proposto}
Não é incomum em aplicações embarcadas que uma parcela considerável da computação seja efetuada por circuitos especializados, devido às demandas de performance e eficiência. De fato, segundo~\cite{Dally:2008}, um ASIC (\ingles{application-specific integrated circuit}) pode atingir uma eficiência de $5pJ/op$ na tecnologia CMOS de 90-nm. Por outro lado, processadores embarcados altamente eficientes atingem apenas $250 pJ/op$, uma perda de 50x. É evidente, então, a troca da flexibilidade de um processador de propósito geral pela eficiência propiciada por ASICs.

Nota-se, porém, que o tempo de design de um ASIC pode ser considerável e que muitas aplicações não se adequam a inflexibilidade propiciada por essa solução. Soluções flexíveis são necessárias em classes de problemas onde o desenvolvimento de novos algoritmos ou o surgimento repentino de uma demanda inesperada são comuns. Em criptografia, um exemplo de tal demanda pode ser a descoberta de um novo ataque a algum cifrador, o que poderia requerer o aumento de algum parâmetro, como tamanho de chave, ou até mesmo a troca por outro algoritmo, o que é facilitado em implementações via software. Pode-se citar um caso onde uma especificação de hardware não acompanhou a evolução de algoritmos criptográficos: em 2011, o conjunto de instruções ARMv8 para processadores ARM foi anunciado, trazendo instruções específicas para os algoritmos SHA1 e SHA2. O primeiro foi considerado inseguro e seu uso descontinuado a partir de 2010, enquanto o segundo já teve seu sucessor escolhido via competição em 2012~\cite{sha3}.

A busca por soluções eficientes em software para criptografia, então, não deve ser desconsiderada. Em se tratanto de eficiência energética em um processador embarcado, os fatores mais impactantes são ilustrados pela figura~\ref{fig:energy_usage}. Observa-se que o fornecimento de dados e instruções totaliza $70\%$ da energia total consumida, tornando-se alvos importantes para otimizações. Com base nisso, o presente trabalho irá analisar o comportamento do sistema de memórias de um processador embarcado executando algoritmos de curvas elípticas, variando-se parâmetros do processador (como tamanho e associatividade das caches), parâmetros do algoritmo (como as curvas utilizadas e o tamanho de chaves) e aplicando-se técnicas de otimização voltadas à eficiência energética. Assim, será possível relacionar a influência de tais parâmetros no consumo de energia pelo sistema de memória.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/intro_energy_usage.png}
\caption{Consumo de energia em um processador embarcado~\cite{Dally:2008}}
\label{fig:energy_usage}
\end{center}
\end{figure}

O trabalho está dividido da seguinte maneira: o capítulo~\ref{ch:basic_crypto} define os conceitos básicos em criptografia e situa o contexto em que algoritmos de ECC são necessários, o capítulo~\ref{ch:correlatos} detalha os trabalhos correlatos, o capítulo~\ref{ch:experimentos} expõe os experimentos realizados, a metodologia adotada e resultados obtidos. Por fim, o capítulo~\ref{ch:conclusao} conclui o trabalho e levanta possibilidades de trabalhos futuros.


\chapter{Conceitos Básicos em Criptografia}
\label{ch:basic_crypto}
A presente seção pretende introduzir o leitor aos conceitos básicos de criptografia, iniciando por definições clássicas, seguido dos conceitos relacionados à criptografia simétrica. O material desta seção é baseado principalmente no trabalho de Goldreich~\cite{Goldreich:2006:FCV:1202577} e nas notas de aula do professor Charles Rackoff~\cite{Rackoff}, apresentando apenas uma síntese do conteúdo. O leitor interessado na bela teoria que suporta a criptografia é incentivado a consultar as referências indicadas. Embora não seja fundamental ao entendimento do resto deste trabalho, a primeira parte do capítulo é importante por situar o leitor no contexto em que a criptografia assimétrica é necessária.

Em seguida, o conceito de curva elíptica é apresentado, assim como operações necessárias à definição do logaritmo discreto. Um conhecimento básico de teoria de grupos é assumido, embora os conceitos mais importantes sejam revisados. Muitos dos exemplos e definições utilizados são baseados no anexo A do padrão IEEE 1363,~\cite{IEE1363}.

\section{Sessões seguras}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/crypto_model.png}
\caption{Modelo de uma sessão segura~\cite{Rackoff}}
\label{fig:crypto_model}
\end{center}
\end{figure}

A aplicação mais tradicional de criptografia, aquela descrita por um usuário comum de informática, encontra-se no estabelecimento de \keyword{sessões seguras} (\ingles{secure sessions}). Isto é, duas pessoas, $A$ e $B$, tendo um segredo em comum (daqui em diante chamado de \keyword{chave}), gostariam de se comunicar através de um canal potencialmente inseguro. Com alguma frequência, $A$ gostaria de mandar algo\footnote{Tratamos de comunicação unidirecional aqui por simplicidade, todos os conceitos podem ser expandidos para um canal bidirecional.} (\keyword{texto em claro}, \ingles{plaintext}) para $B$; denotar-se-á por \keyword{mensagem} tudo aquilo que $A$ gostaria de enviar para $B$, embora $A$ esteja restrito a enviar uma fração de tal mensagem por vez. Considera-se também a existência de um adversário $ADV$ computacionalmente irrestrito, limitado a ouvir tudo que $A$ envia pelo canal. Informalmente, $A$ gostaria de cifrar a mensagem de modo que $ADV$ não possa descobrir nenhuma informação sobre a mesma.


Tal cenário é representado pela figura~\ref{fig:crypto_model} e motiva a primeira definição aqui apresentada:

\begin{definicao}
Diremos que uma chave é um $K \in \{0,1\}^n$, onde $K = K_1K_2\dots K_n$, e uma mensagem é um $M \in \{0,1\}^m$, onde $M = M_1M_2\dots M_m$.

Uma \ingles{encryption function} é uma função \[Enc: \{0,1\}^m \times \{0,1\}^n \to \{0,1\}^*\]

Uma \ingles{decryption function} é uma função \[Dec: \{0,1\}^* \times \{0,1\}^n \to \{0,1\}^m\]

Requer-se do par $(Enc, Dec)$ a seguinte \keyword{condição de corretude}: \[\forall M \in \{0,1\}^m,  \forall K \in \{0,1\}^n Dec(Enc(M, K), K) = M\]
\end{definicao}

Informalmente, $Enc(M,K)$ é entendido como  a mensagem $M$ cifrada que $A$ envia a $B$, o qual aplica $Dec$ para retornar ao texto em claro. É importante insistir na condição de corretude, uma vez que ela garante que qualquer mensagem cifrada por $Enc$ será corretamente produzida por $Dec$, desde que a mesma chave seja usada em ambas as funções\footnote{É comum nos referimos ao par $(Enc, Dec)$ quando queremos discutir alguma propriedade criptográfica, visto que as duas funções geralmente estão relacionadas para conferir corretude. É um exercício interessante pensar como seria fácil obter segurança sem o requerimento de corretude.}.

Pode-se agora descrever o que seria uma função segura. Existem diversas definições provadamente equivalentes na literatura, por simplicidade a definição seguinte é adotada neste trabalho:

\begin{definicao}
O par $(Enc, Dec)$ é dito \keyword{perfeitamente seguro} se, para toda $f:\{0,1\}^* \to \{0,1\}^m$, a seguinte proposição é válida:

Considere o experimento em que $M$ é escolhida de modo aleatório de $\{0,1\}^m$ e $K$ é escolhida de modo aleatório de $\{0,1\}^n$. Então deve ser  verdade que: \[P[f(Enc(M,K)) = M] = 1/2^m\]
\end{definicao}

Isto é, um adversário vendo a mensagem cifrada não consegue adivinhar o valor de $M$ com probabilidade maior do que se ele simplesmente escolhesse uma mensagem aleatória. Note que o fato do adversário estar ilimitado computacionalmente é representado pelo fato de que ele é modelado como uma função arbitrária na definição.
 
No caso em que $n > m$, não é difícil provar a existência de um par $(Enc, Dec)$ perfeitamente seguro: as funções $Enc(M,K) = M_1 \oplus K_1 M_2 \oplus K_2 \dots M_m \oplus K_m$ e $Dec(X,K) = X_1 \oplus K_1 X_2 \oplus K_2 \dots X_m \oplus K_m$ satisfazem a definição\footnote{Tal função é conhecida como \ingles{one-time pad} na literatura.}. Na prática, porém, essa definição não é muito interessante, visto que gostaríamos de trabalhar com chaves pequenas (algumas centenas de bits) e mensagens de tamanho arbitrário\footnote{Embora o termo arbitrário seja utilizado, na prática espera-se que esse número seja muito inferior a $2^n$}. Essa necessidade entra diretamente em conflito com o seguinte teorema:

\begin{teorema}
Se $m > n$ então nenhum $(Enc, Dec)$ é perfeitamente seguro.
\end{teorema}

A prova, embora simples, é omitida por estar fora do escopo do trabalho e pode ser consultada nas referências indicadas. Para contornar esse teorema poderoso, adicionaremos a restrição de que $ADV$ deve ser um algoritmo o qual executa em tempo polinomial (em relação a $n$) e definiremos uma classe de funções com a qual trabalharemos.

\begin{definicao}
Um \keyword{gerador de funções} (\ingles{Function Generator}) $F$ associa a cada $n\in\mathbb{N}$ e a cada $k \in \{0,1\}^n$ uma função $F_k: \{0,1\}^n \to \{0,1\}^n$ de modo que exista um algoritmo com tempo de execução polinomial (em $n$) o qual compute $F_k(x)$.
\end{definicao}

Exige-se que tais geradores de função sejam \keyword{pseudo-aleatórios}, isto é, um adversário não consegue distinguir entre um $F_k$ (para um $k$ escolhido aleatoriamente) e uma função escolhida aleatoriamente $f:\{0,1\}^n \to \{0,1\}^n$ com probabilidade superior a $1/n^c$ para todo $c$ e para $n$ suficientemente grande.

Assume-se que os algoritmos $AES$ e $DES$ se comportem como geradores de funções pseudo-aleatórios\footnote{Um pequeno abuso é feito nessa afirmação, visto que esses algoritmos são definidos para alguns poucos valores de $n$.}. O primeiro, por exemplo, associa uma chave $k$ de 128 (196 ou 256) bits com a função $AES_k$ e é esta função que $A$ tipicamente usa para enviar sua mensagem para $B$. De fato, esses algoritmos são construídos de modo as que funções geradas sejam também permutações, permitindo que se utilize $Enc = AES_k$ e $Dec = AES^{-1}_k$. A razão pela qual simplesmente \emph{assumimos} que geradores de função pseudo-aleatórios existam é devido ao fato dessa ser uma afirmação mais forte que $P \not= NP$, e somos incapazes de provar isso. De fato, uma condição necessária para a segurança de toda criptografia moderna é que $P \not= NP$, embora essa não seja uma condição suficiente.\footnote{O leitor intrigado por essa observação pode notar que não basta ser difícil quebrar um sistema criptográfico no pior caso, e é essa noção que é capturada pelo problema $P \not= NP$. É possível construir um sistema criptográfico para o qual o problema de distiguir $Enc$ é NP-Completo, embora exista um algoritmo eficiente que o resolva em $99\%$ dos casos~\cite{Goldreich:2006:FCV:1202577}.}


\section{Curvas Elípticas}
Até esse momento, assumiu-se que $A$ e $B$ haviam previamente combinado uma chave para efetuar a comunição segura. Tal hipótese pode ser suficiente para ambientes em que poucos pares precisam se comunicar, porém não é adequada para a maioria dos outros cenários. Essa observação motiva o principal objetivo da criptografia assimétrica: como fazer com que duas pessoas possam trocar alguns poucos parâmetros através de um canal inseguro e, ao final da comunicação, ambas compartilhem uma mesma chave desconhecida a qualquer adversário manipulando o canal?

Atualmente, esse objetivo é atingido com o uso de algumas conjecturas da teoria dos números. Uma delas é a dificuldade (de alguma versão) do problema do logaritmo discreto. Neste trabalho, estamos interessados na variação de curvas elípticas do problema, o assunto da presente seção.

\begin{definicao}
    Um conjunto $F$ com um elemento $0$ e duas operações binárias $+$ e $\cdot$ é um \keyword{corpo finito} (\ingles{finite field}, ou \ingles{Galois field}) se as seguintes condições forem verdadeiras:
    \begin{enumerate}
        \item $F$ é um conjunto finito
        \item $+$ é uma operação associativa
        \item $+$ é uma operação comutativa
        \item $0$ é o elemento neutro de $+$
        \item Cada elemento de $F$ possui um inverso para $+$ em $F$
        \item $\cdot$ é uma operação associativa
        \item $\cdot$ é uma operação comutativa
        \item Distributividade de $\cdot$ em relação a $+$ (à esquerda e à direita)
        \item Existência de um elemento neutro ($1$) para $\cdot$
        \item Todo elemento de $F$ diferente de $0$ possui uma inversa para $\cdot$ em $F$
    \end{enumerate}
\end{definicao}

\begin{definicao}
    Dado um número primo $p$, o conjunto dos números inteiros módulo p com as operações habituais de soma e multiplicação é um corpo finito, denotado $GF(p) = \{0, 1, \ldots, p-1\}$.
\end{definicao}

    De modo similar, para um primo $q$ e um inteiro positivo $n$, pode-se definir um corpo finito $GF(q^m)$ com o uso de polinomiais, embora sua definição precisa seja omitida por estar fora do escopo deste trabalho.

\begin{definicao}
Uma curva elíptica $E$ sobre o corpo finito $GF(p)$, onde $p$ é um número primo ímpar, é o conjunto: 
\begin{align*} 
	E = \{ (x,y) \quad | \quad &y^2 = x^3 + ax + b \\
							   &\wedge\quad x, y, a, b \in GF(p) \\
							   &\wedge\quad 4a^3 + 27b^2 \not= 0\; (mod \;p) \} \cup \{ O\}
\end{align*}
	
	onde $a$ e $b$ são constantes relacionadas a curva e $O$ é chamado de ponto no infinito.
\end{definicao}

Pode-se também criar uma curva elíptica sobre $GF(2^m)$, cuja definição é dada a seguir, embora os demais conceitos desse capítulo sejam tratados apenas para o caso de $GF(p)$ para evitar demasiadas repetições. É importante lembrar, porém, que a escolha do corpo tem implicações tanto no modo como seus elementos são representados em memória como na definição de operações e algoritmos. 

\begin{definicao}
Uma curva elíptica $E$ sobre o corpo finito $GF(2^m)$, é o conjunto: 
\begin{align*} 
	E = \{ (x,y) \quad | \quad &y^2 + xy = x^3 + ax^2 + b \\ 
							   &\wedge\quad x, y, a, b \in GF(2^m) \quad\wedge\quad b \not= 0\} \cup \{ O\}
\end{align*}

	onde $a$ e $b$ são constantes relacionadas a curva e $O$ é chamado de ponto no infinito.
\end{definicao}

\begin{definicao}
	O número de elementos de uma curva elíptica $E$ é chamado de \keyword{ordem} de $E$ e é denotado por $\#E(GF(q))$.
\end{definicao}

Para ilustrar as definições, considere a curva $E$ dada por \[y^2 = x^3 + x + 5\] sobre $GF(13)$. Os pontos de $E$ são:
\[ \{O, (1,4), (1,9), (3,6), (3,7), (8,5), (8,8), (10,0), (11,4), (11,9) \} \]
e $\#E(GF(13)) = 10$.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/ecc_example_overGF.png}
\caption{Exemplo de uma curva elíptica sobre $GF(13)$}
\label{fig:ecc_example_overGF}
\end{center}
\end{figure}


\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/ecc_example_overR.png}
\caption{Exemplo de uma curva elíptica sobre $\mathbb{R}$}
\label{fig:ecc_example_overR}
\end{center}
\end{figure}

A figura~\ref{fig:ecc_example_overGF} ilustra os pontos da curva sobre $GF(13)$ e, para comparação, a mesma curva é desenhada sobre os reais na figura~\ref{fig:ecc_example_overR}. Como se pode observar, a troca de domínio muda consideravelmente a aparência da curva.
%Dá uma olhada na matplotlib   /numpy

    \begin{codebox}
	\label{alg:sum_over_ECC}
    \Procname{$\proc{Soma}(P_1, P_2)$}
	\li \If $P_1 = O$ 			\label{li:sum-zero-begin}
	\Do
		\li output $P_2$ and stop. 
	\End
	\li \If $P_2 = O$ 
	\Do
		\li output $P_1$ and stop. 
	\End						\label{li:sum-zero-end}
	\li Set $x_1 \gets P_1.x$
	\li Set $y_1 \gets P_1.y$
	\li Set $x_2 \gets P_2.x$
	\li Set $y_2 \gets P_2.y$
	\li \If $x_1 \not= x_2$ 	\label{li:sum-lambda1-begin}
	\Do	
		\li Set $\lambda \gets (y_1 - y_2)/(x_1 - x_2)$ \label{li:sum-lambda1-end}
	\li \Else
	\li \If $y_1 \not= y_2$ or $y_2 = 0$ \label{li:sum-sumzero-begin}
		\Do
			\li Output $O$ and stop.
		\End							\label{li:sum-sumzero-end}
		\li Set $\lambda \gets (3{x_2}^2 + a)/(2y_2)$	\label{li:sum-lambda2}
	\End
	\li Set $x_3 \gets \lambda^2 - x_1 - x_2 \quad mod\; p$		\label{li:sum-final-begin}
	\li Set $y_3 \gets (x_2 - x_3)\lambda - y_2 \quad mod\; p$	\label{li:sum-final-end}
	\li output $(x_3, y_3)$
    \end{codebox}


	Uma operação de soma ($+$) pode ser definida sobre uma curva elíptica de modo a torná-la um grupo e, assim, poderemos definir o problema do logaritmo discreto sobre esse conjunto. Intuitivamente, tem-se que a soma de dois pontos $P_1 + P_2$ é o ponto $P_3$ com a propriedade que $P_1$, $P_2$ e $-P_3$ são colineares. Para um ponto $P = (x, y)$, define-se $-P = (x, -y)$. Por clareza, definimos a soma de dois elementos de $E$ para o caso de $GF(p)$ através do algoritmo \proc{Soma}, conforme~\cite{IEE1363}.  As linhas~\ref{li:sum-zero-begin}--~\ref{li:sum-zero-end} tratam o ponto no infinito, $O$, como o elementro neutro da operação. No caso em que os pontos não possuam a mesma coordenada $x$, as linhas~\ref{li:sum-lambda1-begin}--~\ref{li:sum-lambda1-end} calculam o coeficiente angular da reta secante que passa por $P_1$ e $P_2$, enquanto calcula-se o coeficiente da reta tangente a curva em um dos pontos quando $P_1 = P_2$ (linha~\ref{li:sum-lambda2}). Caso os pontos difiram apenas na coordenada $y$, então temos $P_1 = -P_2$ e o algoritmo retorna o elemento neutro (linhas~\ref{li:sum-sumzero-begin}--~\ref{li:sum-sumzero-end}). Por fim, as linhas~\ref{li:sum-final-begin}--~\ref{li:sum-final-end} utilizam o coeficiente mencionado anteriormente para calcular as coordenadas de $P_3$.

	Note que, embora os termos como coefienciente angular e reta tangente sejam utilizados, os quais estão normalmente relacionados a funções sobre o domínio dos reais, o algoritmo opera sobre $GF(13)$, logo todas as operações de soma, subtração, multiplicação ou divisão que aparecem no algoritmo \proc{Soma} devem ser realizadas $mod\; p$. Isso ilustra uma das primeiras dificuldades de implementação de algoritmos relacionados a curvas elípticas: as operações de multiplicação e inversão em $GF(p)$ não são triviais.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/ecc_example_addition.png}
\caption{Somando pontos em uma curva elíptica sobre $GF(13)$}
\label{fig:ecc_example_addition}
\end{center}
\end{figure}

Com isto em mente, a intuição dada pelo domínio real ajuda a visualizar a soma em $GF(p)$. Utilizando a mesma curva do exemplo anterior, a figura~\ref{fig:ecc_example_addition} ilustra a adição dos pontos $P_1 = (10,0)$ e $P_2= (8,5)$. Primeiro, a reta que sai de $P_1$ e passa por $P_2$ é traçada. Quando esta reta atinge os limites do gráfico, isto é, uma de suas coordenadas atinge o valor $13$ (ou $0$), pode-se entender que a operação de módulo é aplicada, efetivamente continuando a reta no lado oposto do gráfico. Tal procedimento é repetido até que um ponto de $E$, aqui chamado de $-P_3$, seja encontrado, de modo que $P_1$, $P_2$ e $-P_3$ sejam colineares. A soma de $P_1$ e $P_2$ é dada então por $P_3$. Note ainda que, caso dois pontos tenham a mesma coordenada $x$, a reta que passa por ambos está na vertical e, portanto, nunca tocará um terceiro ponto de $E$ que não seja o ponto no infinito, $O$.

Algebricamente, teríamos que:

\begin{align*} 
	\lambda &= (y_1 - y_2) / (x_1 - x_2) \quad mod\; p\\
			&= (0 - 5) / (10 - 8) \quad mod\; 13\\
			&= -5 / 2  \quad mod\; 13 \\
			&= 8 * 7 \quad mod\; 13 \\
			&= 4
\end{align*}

\begin{align*} 
	x_3 &= \lambda ^2 - x_1 - x_2 \quad mod\; p \\
		&= 4^2 - 10 - 8 \quad mod \; 13 \\
		&= 11
\end{align*}
	
\begin{align*} 
	y_3 &= (x_2 - x_3)\lambda -y_2 \quad mod\; p \\
		&= (8-11)4 - 5 \quad mod \; 13 \\
		&= 9
\end{align*}

O que é equivalente às coordenadas de $P_3$ obtidas geometricamente.

Como consequência da operação de adição, pode-se definir a multiplicação de um ponto por um escalar. Se $k \in \mathbb{Z}$ e $P \in E$, então: 

 \begin{displaymath}
   kP = \left\{
     \begin{array}{lr}
       $O$ & : k = 0\\
       $(-k)(-P)$ & : k < 0 \\
       $P + (k-1)P$ & : k > 0
     \end{array}
   \right.
\end{displaymath} 

\begin{definicao}
A \keyword{ordem} de um ponto $P$ em uma curva elíptica $E$ é o menor inteiro positivo $r$ tal que \[rP = O\]
\end{definicao}

Da álgebra, tem-se que a ordem de um ponto sempre existe e divide a ordem da curva, $\#E(GF(p))$. Além disso, se $k$ e $l$ são inteiros, então $kP = lP$ se, e somente se, $k \equiv l \quad mod\; p$.

Pode-se agora definir o logaritmo discreto de um ponto em uma curva elíptica:

\begin{definicao}
	\label{def:logdiscreto}
Suponha que um ponto $G$ em uma curva $E$ tenha ordem $r$, onde $r^2$ não divida a ordem da curva $\#E(GF(p))$. Então um ponto $P$ satisfaz $P = lG$ para algum $l$ se, e somente se, $rP = O$. O coeficiente $l$ é chamado de \keyword{logaritmo discreto} de $P$ em relação ao ponto base $G$.
\end{definicao}

Uma comparação com o logaritmo tradicional pode ser feita para o entendimento da definição: enquanto $log_b x$ responde a pergunta de quantas vezes $b$ deve ser \textbf{multiplicado} por ele mesmo até que se encontre $x$, o logaritmo discreto de $P$ trabalha com quantas vezes precisa-se \textbf{somar} $G$ até que se encontre $P$. Mais formalmente, tem-se~\cite{CryptoEncyc}:

\begin{definicao}
	Considere uma curva elíptica $E$ e um ponto $P\in E$ de ordem $n$. Dado um ponto $Q \in \langle P \rangle = \{0, P, 2P, \dots (n-1)P\} $, o \textbf{problema do logaritmo discreto sobre curvas elípticas} (ECDLP) consiste em computar $0 \leq l \leq n-1$ tal que $Q = lP$.
\end{definicao}

O algoritmo ingênuo para resolver uma instância de ECDLP consiste em computar os múltiplos de $P$ até que se encontre $Q$, o que pode levar até $n$ adições, impraticável para valores muito altos de $n$. Atualmente, os melhores algoritmos conhecidos são baseados em variações do método \ingles{Pollard's $\rho$} e executam em tempo $O(\sqrt{n})$~\cite{Pollard1}\cite{Pollard2}.

\section{\ingles{Elliptic Curve Diffie Hellman}}
Em 1976,  Whitfield Diffie e Martin Hellman publicaram um método para a troca de chaves em um canal inseguro~\cite{DiffieHellman} o qual é baseado no problema do logaritmo discreto de inteiros em $GF(p)$. Embora não forneça autenticação (isto é, $A$ não possui garantias de que está de fato conversando com $B$\footnote{Nenhum dos protocolos apresentados aqui possuirá essa característica, visto que é algo difícil de ser alcançado sem uma Infraestrutura de Chaves Públicas (\ingles{Public Key Infrastructure}) previamente estabelecida. Atualmente, isto é feito através de certificados e autoridades certificadoras. Ainda assim, tais protocolos são realistas e são utilizados em versões autenticadas dos mesmos.}), ele é a base de protocolos autenticados. Pouco tempo depois, em 1978, a dificuldade da fatoração de números inteiros foi utilizada por R.L. Rivest, A. Shamir, e L. Adleman para atingir o mesmo propósito, no algoritmo conhecido como $RSA$~\cite{Rivest:1978:MOD:359340.359342}. Em 1985, dois autores propuseram independentemente o uso de curvas elípticas para a troca de chaves (\cite{koblitz1987elliptic},~\cite{Miller}) com tais métodos se popularizando a partir de 2004\footnote{Mais recentemente, as pesquisas em algoritmos baseados em Retículos (\ingles{Lattices}) ressurgiram, visto que essa é uma classe de algoritmos resistentes a ataques por computadores quânticos, ao contrário daqueles baseados em Diffie-Hellman e RSA. }.

Descreve-se aqui um dos protocolos padronizados em~\cite{IEE1363}, lá referenciado por DL/ECKAS-DH1, ou \ingles{Discrete Logarithm and Elliptic Curve Key Agreement Scheme, Diffie-Hellman version}. $A$ e $B$ devem executar os seguintes passos para o estabelecimento de uma chave:

\begin{enumerate}
	\item Em comum acordo, estabelecer um conjunto de parâmetros do domínio a ser trabalhado: os coeficientes $a$ e $b$ da curva, o número primo $p$ e um ponto $G$ de ordem $r$.
	\item Escolher um número inteiro aleatório $s$ no intervalo $[1, r-1]$ e computar o ponto $W = sG$. O par $(s,W)$ consiste da chave pública e privada, respectivamente.
	\item Obter da outra parte a chave pública $W'$.
	\item Computar $P = sW' = (x_P, y_P)$. $x_P$ será considerado o segredo compartilhado.
	\item Aplicar uma função de derivação de chave sobre $x_P$.
\end{enumerate}

As etapas, embora simples, merecem diversas considerações adicionais. Os parâmetros de domínio não podem ser gerados de forma totalmente aleatória: diversas curvas anômalas precisam ser evitadas por permitirem a simplificação do ECDLP, assim como impõe-se restrições sobre a fatoração de $r$ para evitar o mesmo problema. Tipicamente, utilizam-se parâmetros pré-estabelecidos por padrões, como as curvas padronizadas pelo NIST (\ingles{National Institute of Standards and Technology})~\cite{Barker:2007:SRP:2206270}\footnote{Essas curvas foram escolhidas, em teoria, por possuírem características adequadas para o ECDLP e por permitirem implementações eficientes das operações de grupo. Existem, no entanto, algoritmos para gerar parâmetros seguros caso o uso de curvas estabelecidas por organizações seja um inconveniente.}.

Ao receber de $B$ o valor $W'$, $A$ pode utilizar o critério da definição~\ref{def:logdiscreto} para verificar que $W'$ é, de fato, um múltiplo de $G$. Nota-se também que, até esse momento, todas as mensagens foram trocadas em um canal inseguro: qualquer adversário pode ter acesso aos parâmetros de domínio, bem como a $W$ e $W'$ (o primeiro é enviado por $A$ para $B$ e o segundo por $B$ para $A$). Porém apenas $A$ e $B$ conseguem computar facilmente o valor $P = sW' = s'W = ss'G$, assumindo que o problema ECDLP seja, de fato, difícil. Por fim, aplica-se alguma função sobre o valor $x_P$ para gerar uma string $k$ de tamanho apropriado, a qual será utilizada em funções como o $AES_k$.

\chapter{Trabalhos Correlatos}
\label{ch:correlatos}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.40]{images/instruction_classes.png}
\caption{Distribuição dos tipos de instruções executadas durante algoritmos de ECC (segunda e terceira colunas) \cite{Branovic}}
\label{fig:instruction_classes}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.33]{images/cache_ecc_aes.png}
\caption{Comparação entre os acertos em cache dos algoritmos de ECC (colunas ec-dh) e AES (colunas bf) \cite{Branovic}}
\label{fig:cache_ecc_aes}
\end{center}
\end{figure}

As primeiras publicações as quais investigaram a performance de sistemas de criptografia baseados em curvas elípticas possuiam um grande enfoque em tempo de execução. Em~\cite{Hankerson}, realizou-se um levantamento extensivo de diversas implementações para as operações aritméticas em $GF(2^m)$, assim como algoritmos para multiplicação por escalar em curvas, e o tempo de execução em um processador de desktop da época foi reportado.~\cite{Aydos} apresentaram uma biblioteca para um processador ARM de 32 bits com operações para curvas em $GF(p)$, reportando tempo de execução para o ECDSA (\ingles{Elliptic Curve Digistal Signature Algorithm}), o qual utiliza as mesmas primitivas que ECDH.

O trabalho de~\cite{Bartolini}, a partir do simulador Superscalar para a arquitetura ARM, foi o primeiro a reportar dados do comportamento do sistema de memória para algoritmos de ECC, embora para uma única configuração de cache. Além disso, encontram-se dados sobre CPI e tempo de execução por procedimento do algoritmo, bem como a proposta de uma instrução para multiplicação de polinomiais e o impacto que isso teria no algoritmo. Tal proposta é interessante visto que, anos depois, o conjunto de instruções ARMv8 trouxe uma instrução similar, embora não se encontrou nenhuma técnica utilizando ela na prática.

Em uma continuação desse trabalho,~\cite{Branovic} realizaran uma análise da distribuição dos tipos de instrução executadas pelo algoritmo, onde pode-se observar que instruções de ALU totalizam $60\%$ do total de executadas (figura~\ref{fig:instruction_classes}), resultado confirmado pelos trabalhos de~\cite{Gouvea} e~\cite{Gura}. Outra contribuição consiste na comparação do \ingles{miss rate} entre algoritmos simétricos e assimétricos, onde pode-se observar que os algoritmos de ECC são muito menos intensivos na cache de dados quando comparados ao AES, embora detalhes da implementação deste não sejam reportados. Além disso, a diferença entre o \ingles{miss rate} na cache de dados e na de instruções chega a uma ordem de magnitude, conforme a figura~\ref{fig:cache_ecc_aes}.

Outro conjunto de trabalhos passa a focar em processadores utilizados em sensores, como~\cite{Gura}, o qual comparou o tempo de execução, uso de memória e tamanho do código para os algoritmos RSA e ECC em um ATmega128. As conclusões apresentadas em tal trabalho indicam que os algoritmos baseados em RSA podem ser até uma ordem de magnitude mais lentos, embora espere-se que essa diferença seja menor para processadores com tamanho de palavra maior. Uma implementação detalhada para plataforma de sensores MICA, a qual utiliza o processador ATmega128, é descrita em~\cite{Wang}, embora não sejam informados dados de eficiência enérgica. Um trabalho por~\cite{Gouvea} compara esquemas de ECC com esquemas baseados em identidades e pareamentos, onde conclui-se que os primeiros possuem um desempenho superior. Uma segunda contribuição do trabalho consiste em demonstrar a importância do uso apropriado de otimizações voltadas a arquitetura alvo, visto que os autores foram os primeiros a considerar a instrução de \ingles{multiply and accumulate} do processador MSP430 ao desenvolverem sua implementação. Nessa mesma plataforma,~\cite{Mane} reporta o consumo energético ao variar-se a frequência operada bem como a presença de multiplicador em hardware, atributo o qual não está presente em todas as versões do MSP430.

Quatro anos após a prova em silício de que algoritmos de ECC podem ser utilizados em RFID~\cite{Hein:2009}, apresentou-se uma implementação em software para a plataforma RFID conhecida como WISP~\cite{Pelnar}. Neste trabalho, apenas a menor curva padronizada pelo NIST é utilizada, reportando tempo de execução de 1.6 segundos para multiplicação de um ponto da curva por um escalar.

O trabalho de~\cite{deClerc} avalia o uso de curvas elípticas com o recém lançado processador Cortex M0+ da ARM (32 bits), propondo um novo algoritmo para multiplicação em $GF(q)$. Além disso, o custo enérgico de cada instrução executada pelo processador é avaliado e o desempenho dos algoritmos criptográficos calculado com base em tais valores. Infelizmente, o trabalho se concentra em curvas especiais e não naquelas padronizadas. De modo similar,~\cite{Liu} explora duas formas especiais de curvas elípticas (\ingles{Montgomery} e \ingles{Twisted Edwards}) bem como a equivalência existente entre elas para diminuir o custo das operações de grupo. A importância do uso de curvas padronizadas é discutida em~\cite{Wenger}, onde os autores desenvolvem clones VHDL (precisos em ciclo) dos processadores ATmega128, MSP430 e Cortex M0+ e simulam o uso de tais curvas. Destaca-se que o processador ARM alcança a melhor eficiência energética e tempo de execução enquanto o MSP430 ocupa a menor área em silício e demanda a menor potência. Por fim, deve-se mencionar que o estado da arte em termos de velocidade encontra-se no trabalho publicado por~\cite{Liu2}, o qual, embora não utilize curvas padronizadas, afirma trabalhar sobre um corpo finito mais compatível com outras implementações de ECC.

%\chapter{Experimentos realizados}
%\label{ch:experimentos}
%\chapter{Conclusões e trabalhos futuros}
%\label{ch:conclusao}



\bibliographystyle{ufscThesis/ufsc-alf}
\bibliography{bibliografia}

\end{document}
