\documentclass{ufscThesis}

\usepackage{graphicx} % Possibilita o uso de figuras e gráficos
\usepackage{epsfig}
\usepackage{color, colortbl}    % Possibilita o uso de cores no documento
\usepackage{multirow, amsmath}
\usepackage{clrscode3e}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{caption, float}
\usepackage[export]{adjustbox}
\usepackage{pdfpages}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{amssymb}



%----------------------------------------------------------------------
% Comandos criados pelo usuário
\newcommand{\ABNTbibliographyname}{REFERÊNCIAS}
\newcommand{\afazer}[1]{{\color{red}{#1}}} % Para destacar uma parte a ser trabalhada
\newcommand{\ingles}[1]{\emph{#1}}
\newcommand{\keyword}[1]{\emph{#1}}
\newtheorem{definicao}{Definição}
\newtheorem{teorema}{Teorema}

%----------------------------------------------------------------------
% Identificadores do trabalho
% Usados para preencher os elementos pré-textuais
\instituicao[a]{Universidade Federal de Santa Catarina} % Opcional
\departamento[a]{Departamento de Informática e Estatística}
\curso[o]{Curso de Bacharelado em Ciência da Computação}
%\documento[o]{TCC} % Opcional (Tese é o padrão)
\titulo{Análise da eficiência energética de algoritmos de criptografia baseados em curvas elípticas}
%\subtitulo{} % Opcional
\autor{Felipe de Azevedo Piovezan}
\grau{Bacharel em Ciência da Computação}
\local{Florianópolis - Santa Catarina} % Opcional (Florianópolis é o padrão)
\data{02}{Dezembro}{2015}
\orientador[Orientador]{Prof. Dr. Luiz Cláudio Villar dos Santos}
\coorientador[Coorientador]{Prof. Dr. Daniel Santana de Freitas}
\coordenador[Coordenador]{Prof. Dr. Renato Cislaghi}

\numerodemembrosnabanca{5} % Isso decide se haverá uma folha adicional
\orientadornabanca{sim} % Se faz parte da banca definir como sim
\coorientadornabanca{sim} % Se faz parte da banca definir como sim
\bancaMembroA{Prof. Dr. Luiz Cláudio Villar dos Santos} %Nome do presidente da banca
\bancaMembroB{Prof. Dr. José Luís Almada Güntzel}      % Nome do membro da Banca
\bancaMembroC{Prof. Dr. Daniel Santana de Freitas}     % Nome do membro da Banca
%\bancaMembroD{Quarto membro}       % Nome do membro da Banca
%\bancaMembroE{Prof. quinto membro}       % Nome do membro da Banca
%\bancaMembroF{Prof. sexto membro}        % Nome do membro da Banca
%\bancaMembroG{Prof. sétimo membro}       % Nome do membro da Banca

\agradecimento{
Um agradecimento
}

\epigrafe{"Nevermore"}
{The Raven}

\textoResumo {
	A criptografia de chaves públicas (PKC), ou criptografia assimétrica, uma das bases para a comunicação segura pela internet, fornece as primitivas para a troca de chaves, autenticação de usuários e assinatura digital. A maioria dos algoritmos de PKC usados atualmente são baseados em conjecturas de teoria dos números, como a dificuldade da fatoração de inteiros ou a dificuldade de alguma versão do logaritmo discreto. Este último, quando usado na versão de curvas elípticas, permite o uso de chaves e assinaturas menores para o mesmo nível de segurança de outros algoritmos, o que é interessante em ambientes com recursos limitados.

	Durante o desenvolvimento dos algoritmos assimétricos, os principais nodos da rede eram grandes servidores e desktops. Recentemente, porém, a escala dos dispositivos que estabelecem comunicação segura pela internet está diminuindo consistentemente: dos laptops e celulares, até sensores e etiquetas RFID, todos necessitam de um canal seguro. Essa miniaturização, no entanto, veio acompanhada de restrições de processamento e de suprimento energético, o que conflita com o fato que algoritmos de PKC são computacionalmente caros: como, então, utilizá-los em ambientes com recursos limitados? O presente trabalho pretende, a partir de simulações, avaliar o gasto energético do sistema de memórias de processadores executando algoritmos de criptografia de curvas elípticas, bem como o impacto que técnicas de otimização têm na eficiência energética.
}

\palavrasChave {Palavras chave}

\textAbstract {
	The realm of public-key (asymmetric) cryptography (PKC) is considered to be one the pillars of secure communication over the internet, since it includes user authentication, key enchange and digital signatures. PKC algorithms in use are mostly based in certain number-theoretic conjectures, like the difficulty of integer factorization or the difficulty of some discrete-log problem. The latter, when used in the elliptic curve setting, allows for shorter keys and signatures while maintaining the same security level of other algorithms, which is interesting in a resource constrained environment.
	
	During the development of the first asymmetric algorithms, most nodes in a network were either desktops or servers. Recently, however, the scale of the devices partaking in secure communations over the internet has been steadily decreasing: from laptops and cellphones to sensors and RFID tags, they all require a secure channel. This miniaturization is responsible for new restrictions on the processing power and battery supply available to each node, which directly conflicts with the fact that PKC algorithms are computationally expensive. What then is the best way to employ those algorithms in such restricted devices? Through the use of simulations, this work will evalute the energy cost of the memory system of processors executing elliptic curve algorithms, as well as the impact that certain optimzation techniques have on energy efficiency. 
}
\keywords {keywords}

\begin{document}

%--------------------------------------------------------
% Elementos pré-textuais
%\capa  
\folhaderosto[comficha]
\folhaaprovacao
\paginadedicatoria
\paginaagradecimento
\paginaepigrafe
\paginaresumo
\paginaabstract
%\pretextuais % Substitui todos os elementos pre-textuais acima
\listadefiguras % as listas dependem da necessidade do usuário
\listadetabelas 
\listadeabreviaturas
\listadesimbolos
\sumario
%--------------------------------------------------------
% Elementos textuais

\chapter{Introdução}
Introducao!

\chapter{Conceitos Básicos em Criptografia}
A presente seção pretende introduzir o leitor aos conceitos básicos de criptografia, iniciando pelas definições clássicas, seguido dos conceitos relacionados à criptografia simétrica. Por fim, discute-se métodos utilizados para troca de chaves em criptografia assimétrica. O material aqui apresentado é baseado principalmente no trabalho de Goldreich \cite{Goldreich:2006:FCV:1202577} e nas notas de aula do professor Charles Rackoff \cite{Rackoff}. Apresentaremos os conceitos mais importantes para o entendimento do ambiente em que algoritmos de curvas elípticas são utilizados, cientes de que uma abordagem completa estaria fora do escopo deste trabalho. O leitor interessado na bela teoria que suporta a criptografia é incentivado a consultar as referências indicadas anteriormente.

\section{Sessões seguras}

A  aplicação mais tradicional de criptografia, aquela descrita por um usuário comum de informática, encontra-se no estabelecimento de \keyword{sessões seguras} (\ingles{secure sessions}). Isto é, duas pessoas, $A$ e $B$, tendo um segredo em comum (daqui em diante chamado de \keyword{chave}), gostariam de se comunicar através de um canal potencialmente inseguro. Com alguma frequência, $A$ gostaria de mandar algo\footnote{Tratamos de comunicação unidirecional aqui por simplicidade, todos os conceitos podem ser expandidos para um canal bidirecional.} (\keyword{texto em claro}, \ingles{plaintext}) para $B$, denotar-se-á por \keyword{mensagem} tudo aquilo que $A$ gostaria de enviar para $B$, embora $A$ esteja restrito a enviar uma fração de tal mensagem por vez. Considera-se também a existência de um adversário $ADV$ computacionalmente irrestrito, limitado a ouvir tudo que $A$ envia pelo canal. Informalmente, $A$ gostaria de "cifrar" a mensagem de modo que $ADV$ não possa descobrir nenhuma informação sobre a mesma.

Tal cenário motiva a primeira definição aqui apresentada:

\begin{definicao}
Diremos que uma chave é um $K \in \{0,1\}^n$, onde $K = K_1K_2...K_n$, e uma mensagem é um $M \in \{0,1\}^m$, onde $M = M_1M_2...M_m$.

Uma \ingles{encryption function} é uma função \[Enc: \{0,1\}^m \times \{0,1\}^n \to \{0,1\}^*\]

Uma \ingles{decryption function} é uma função \[Dec: \{0,1\}^* \times \{0,1\}^n \to \{0,1\}^m\]

Requer-se do par $(Enc, Dec)$ a seguinte \keyword{condição de corretude}: \[\forall M \in \{0,1\}^m,  \forall K \in \{0,1\}^n Dec(Enc(M, K), K) = M\]
\end{definicao}

Informalmente, $Enc(M,K)$ é entendido como  a mensagem $M$ cifrada que $A$ envia a $B$, o qual aplica $Dec$ para retornar ao texto em claro. É importante insistir na condição de corretude, uma vez que ela garante que qualquer mensagem cifrada por $Enc$ será corretamente produzida por $Dec$, desde que a mesma chave seja usada em ambas as funções\footnote{É comum nos referimos ao par $(Enc, Dec)$ quando queremos discutir alguma propriedade criptográfica, visto que as duas funções geralmente estão relacionadas para conferir corretude. É um exercício interessante pensar como seria fácil obter segurança sem o requerimento de corretude.}.

Podemos agora descrever o que seria uma função segura. Existem diversas definições provadamente equivalentes na literatura, por simplicidade a definição seguinte é adotada neste trabalho:

\begin{definicao}
O par $(Enc, Dec)$ é dito \keyword{perfeitamente seguro} se, para toda $f:\{0,1\}^* \to \{0,1\}^m$, a seguinte proposição é válida:

Considere o experimento em que $M$ é escolhida de modo aleatório de $\{0,1\}^m$ e $K$ é escolhida de modo aleatório de $\{0,1\}^n$. Então deve ser  verdade que: \[P[f(Enc(M,K)) = M] = 1/2^m\]
\end{definicao}

Isto é, um adversário vendo a mensagem cifrada não consegue adivinhar o valor de $M$ com probabilidade maior do que se ele simplesmente escolhesse uma mensagem arbitrária. Note que o fato do adversário estar ilimitado computacionalmente é representado pelo fato de que ele é modelado como uma função arbitrária na definição.
 
No caso em que $n > m$, não é difícil provar a existência de um par $(Enc, Dec)$ perfeitamente seguro: as funções $Enc(M,K) = M_1 \oplus K_1 M_2 \oplus K_2 ... M_m \oplus K_m$ e $Dec(X,K) = X_1 \oplus K_1 X_2 \oplus K_2 ... X_m \oplus K_m$ satisfazem a definição\footnote{Tal função é conhecida como \ingles{one-time pad} na literatura.}. Na prática, porém, essa definição não é muito interessante, visto que gostaríamos de trabalhar com chaves pequenas (algumas centenas de bits) e mensagens de tamanho arbitrário\footnote{Embora o termo arbitrário seja utilizado, na prática espera-se que esse número seja muito inferior a $2^n$}. Essa necessidade entra diretamente em conflito com o seguinte teorema:

\begin{teorema}
Se $m > n$ então nenhum $(Enc, Dec)$ é perfeitamente seguro.
\end{teorema}

A prova, embora simples, é omitida por clareza. Para contornar esse teorema poderoso, adicionaremos a restrição de que $ADV$ deve ser um algoritmo o qual executa em tempo polinomial (em relação a $n$) e definiremos uma classe de funções com a qual trabalharemos.

\begin{definicao}
Um \keyword{gerador de funções} (\ingles{Function Generator}) $F$ associa a cada $n\in\mathbb{N}$ e a cada $k \in \{0,1\}^n$ uma função $F_k: \{0,1\}^n \to \{0,1\}^n$ de modo que exista um algoritmo com tempo de execução polynomial (em $n$) o qual compute $F_k(x)$.
\end{definicao}

Nós iremos exigir que tais geradores de função sejam \keyword{pseudo-aleatórios}, isto é, um adversário não consegue distinguir entre um $F_k$ e uma função escolhida aleatoriamente $f:\{0,1\}^n \to \{0,1\}^n$ com probabilidade superior a $1/n^c$ para todo $c$ e para $n$ suficientemente grande.

Assume-se que os algoritmos $AES$ e $DES$ se comportem como geradores de funções pseudo-aleatórios\footnote{Um pequeno abuso é feito nessa afirmação, visto que esses algoritmos são definidos para alguns poucos valores de $n$.}. O primeiro, por exemplo, associa uma chave $k$ de 128 (196 ou 256) bits com a função $AES_k$ e é esta função que $A$ tipicamente usa para enviar sua mensagem para $B$. De fato, esses algoritmos são construídos de modo as que funções geradas sejam também permutações, permitindo que se utilize $Enc = AES_k$ e $Dec = AES^{-1}_k$. A razão pela qual simplesmente \emph{assumimos} que geradores de função pseudo-aleatórios existem é devido ao fato dessa ser uma afirmação mais forte que $P \not= NP$, e somos incapazes de provar isso.


\section{Criptografia de Chaves Públicas}
Até esse momento, assumimos que $A$ e $B$ haviam previamente combinado uma chave para efetuar a comunição segura. Tal hipótese pode ser suficiente para ambientes em que poucos pares precisam se comunicar, porém não é adequada para a maioria dos outros cenários. Essa observação motiva o principal objetivo da criptografia assimétrica: como fazer com que duas pessoas possam trocar alguns poucos parâmetros através de um canal inseguro e, ao final da comunicação, ambas possuam uma mesma chave desconhecida a qualquer adversário manipulando o canal?

Atualmente, esse objetivo é atingido com o uso de algumas conjecturas da teoria dos números. Uma delas é a dificuldade (de alguma versão) do problema do logaritmo discreto. Neste trabalho, estamos interessados na variação de curvas elípticas do problema, o assunto da presente seção.

\begin{definicao}
Uma curva elíptica $E$ sobre o corpo finito $GF(p)$, onde $p$ é um número primo ímpar, é o conjunto: 
\begin{align*} 
	E = \{ (x,y) \quad | \quad &y^2 = x^3 + ax + b \\
							   &\wedge\quad x, y, a, b \in GF(p) \\
							   &\wedge\quad 4a^3 + 27b^2 \not= 0\; (mod \;p) \} \cup \{ O\}
\end{align*}
	
	onde $a$ e $b$ são constantes relacionadas a curva e $O$ é chamado de ponto no infinito.
\end{definicao}

\begin{definicao}
Uma curva elíptica $E$ sobre o corpo finito $GF(2^m)$, é o conjunto: 
\begin{align*} 
	E = \{ (x,y) \quad | \quad &y^2 + xy = x^3 + ax^2 + b \\ 
							   &\wedge\quad x, y, a, b \in GF(2^m) \quad\wedge\quad b \not= 0\} \cup \{ O\}
\end{align*}

	onde $a$ e $b$ são constantes relacionadas a curva e $O$ é chamado de ponto no infinito.
\end{definicao}

\begin{definicao}
	O número de elementos de uma curva elíptica $E$ é chamado de \keyword{ordem} de $E$ e é denotado por $\#E(GF(q))$.
\end{definicao}

Para ilustrar as definições, considere a curva $E$ dada por \[y^2 = x^3 + x + 5\] sobre $GF(13)$. Os pontos de $E$ são:
\[ \{O, (1,4), (1,9), (3,6), (3,7), (8,5), (8,8), (10,0), (11,4), (11,9) \} \]
e $\#E(GF(13)) = 10$.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/ecc_example_overGF.png}
\caption{Exemplo de uma curva elíptica sobre $GF(13)$}
\label{fig:ecc_example_overGF}
\end{center}
\end{figure}


\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/ecc_example_overR.png}
\caption{Exemplo de uma curva elíptica sobre $\mathbb{R}$}
\label{fig:ecc_example_overR}
\end{center}
\end{figure}

A figura \ref{fig:ecc_example_overGF} ilustra os pontos da curva sobre $GF(13)$ e, para comparação, a mesma curva é desenhada sobre os reais na figura \ref{fig:ecc_example_overR}. Como se pode observar, a troca de domínio muda consideravelmente a aparência da curva.
%Dá uma olhada na matplotlib   /numpy

    \begin{codebox}
		\label{alg:sum_over_ECC}
    \Procname{$\proc{Soma}(P_1, P_2)$}
	\li \If $P_1 = O$ 			\label{li:sum-zero-begin}
	\Do
		\li output $P_2$ and stop. 
	\End
	\li \If $P_2 = O$ 
	\Do
		\li output $P_1$ and stop. 
	\End						\label{li:sum-zero-end}
	\li Set $x_1 \gets P_1.x$
	\li Set $y_1 \gets P_1.y$
	\li Set $x_2 \gets P_2.x$
	\li Set $y_2 \gets P_2.y$
	\li \If $x_1 \not= x_2$ 	\label{li:sum-lambda1-begin}
	\Do	
		\li Set $\lambda \gets (y_1 - y_2)/(x_1 - x_2)$ \label{li:sum-lambda1-end}
	\li \Else
	\li \If $y_1 \not= y_2$ or $y_2 = 0$ \label{li:sum-sumzero-begin}
		\Do
			\li Output $O$ and stop.
		\End							\label{li:sum-sumzero-end}
		\li Set $\lambda \gets (3{x_2}^2 + a)/(2y_2)$	\label{li:sum-lambda2}
	\End
	\li Set $x_3 \gets \lambda^2 - x_1 - x_2 \quad mod\; p$		\label{li:sum-final-begin}
	\li Set $y_3 \gets (x_2 - x_3)\lambda - y_2 \quad mod\; p$	\label{li:sum-final-end}
	\li output $(x_3, y_3)$
    \end{codebox}


	Uma operação de soma ($+$) pode ser definida sobre uma curva elíptica de modo a torná-la um grupo e, assim, poderemos definir o problema do logaritmo discreto sobre esse conjunto. Intuitivamente, tem-se que a soma de dois pontos $P_1 + P_2$ é o ponto $P_3$ com a propriedade que $P_1$, $P_2$ e $-P_3$ são colineares. Para um ponto $P = (x, y)$, define-se $-P = (x, -y)$. Por clareza, definimos a soma de dois elementos de $E$ para o caso de $GF(p)$ através do algoritmo \proc{Soma}, conforme \cite{IEE1363}.  As linhas \ref{li:sum-zero-begin}--\ref{li:sum-zero-end} tratam o ponto no infinito, $O$, como o elementro neutro da operação. No caso em que os pontos não possuam a mesma coordenada $x$, as linhas \ref{li:sum-lambda1-begin}--\ref{li:sum-lambda1-end} calculam o coeficiente angular da reta secante que passa por $P_1$ e $P_2$, enquanto calcula-se o coeficiente da reta tangente a curva em um dos pontos quando $P_1 = P_2$ (linha \ref{li:sum-lambda2}). Caso os pontos difiram apenas na coordenada $y$, então temos $P_1 = -P_2$ e o algoritmo retorna o elemento neutro (linhas \ref{li:sum-sumzero-begin}--\ref{li:sum-sumzero-end}). Por fim, as linhas \ref{li:sum-final-begin}--\ref{li:sum-final-end} utilizam o coeficiente mencionado anteriormente para calcular as coordenadas de $P_3$.

	Note que, embora tenhamos utilizado termos como coefienciente angular e reta tangente, normalmente relacionados a funções sobre o domínio dos reais, estamos trabalhando sobre $GF(13)$, logo todas as operações de soma, subtração, multiplicação ou divisão que aparecem no algoritmo \proc{Soma} devem ser realizadas $mod\; p$. Isso ilustra uma das primeiras dificuldades de implementação de algoritmos relacionados a curvas elípticas: as operações de multiplicação e inversão em $GF(p)$ não são triviais.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/ecc_example_addition.png}
\caption{Somando pontos em uma curva elíptica sobre $GF(13)$}
\label{fig:ecc_example_addition}
\end{center}
\end{figure}

Com isto em mente, a intuição dada pelo domínio real nos ajuda a visualizar a soma em $GF(p)$. Utilizando a mesma curva do exemplo anterior, a figura \ref{fig:ecc_example_addition} ilustra a adição dos pontos $P_1 = (10,0)$ e $P_2= (8,5)$. Primeiro, a reta que sai de $P_1$ e passa por $P_2$ é traçada. Quando esta reta atinge os limites do gráfico, isto é, uma de suas coordenadas atinge o valor $13$, pode-se entender que a operação de módulo é aplicada, efetivamente continuando a reta do lado oposto do grafo. Tal procedimento é repetido até que um ponto de $E$, aqui chamado de $-P_3$, seja encontrado, de modo que $P_1$, $P_2$ e $-P_3$ sejam colineares. A soma de $P_1$ e $P_2$ é dada então por $P_3$. Note ainda que, caso dois pontos tenham a mesma coordenada $x$, a reta que passa por ambos está na vertical e, portanto, nunca tocará um terceiro ponto de $E$ que não seja o ponto no infinito, $O$.

Algebricamente, teriamos que:

\begin{align*} 
	\lambda &= (y_1 - y_2) / (x_1 - x_2) \quad mod\; p\\
			&= (0 - 5) / (10 - 8) \quad mod\; 13\\
			&= -5 / 2  \quad mod\; 13 \\
			&= 8 * 7 \quad mod\; 13 \\
			&= 4
\end{align*}

\begin{align*} 
	x_3 &= \lambda ^2 - x_1 - x_2 \quad mod\; p \\
		&= 4^2 - 10 - 8 \quad mod \; 13 \\
		&= 11
\end{align*}
	
\begin{align*} 
	y_3 &= (x_2 - x_3)\lambda -y_2 \quad mod\; p \\
		&= (8-11)4 - 5 \quad mod \; 13 \\
		&= 9
\end{align*}

O que é equivalente às coordenadas de $P_3$ obtidas geometricamente.
	
\bibliographystyle{ufscThesis/ufsc-alf}
\bibliography{bibliografia}

\end{document}
