\documentclass{ufscThesis}

\usepackage{graphicx} % Possibilita o uso de figuras e gráficos
\usepackage{epsfig}
\usepackage{color, colortbl}    % Possibilita o uso de cores no documento
\usepackage{multirow, amsmath}
\usepackage{clrscode3e}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{caption, float}
\usepackage[export]{adjustbox}
\usepackage{pdfpages}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}
\usepackage{amssymb}



%----------------------------------------------------------------------
% Comandos criados pelo usuário
\newcommand{\ABNTbibliographyname}{REFERÊNCIAS}
\newcommand{\afazer}[1]{{\color{red}{#1}}} % Para destacar uma parte a ser trabalhada
\newcommand{\ingles}[1]{\emph{#1}}
\newcommand{\keyword}[1]{\textbf{#1}}
\newtheorem{definicao}{Definição}
\newtheorem{teorema}{Teorema}

%----------------------------------------------------------------------
% Identificadores do trabalho
% Usados para preencher os elementos pré-textuais
\instituicao[a]{Universidade Federal de Santa Catarina} % Opcional
\departamento[a]{Departamento de Informática e Estatística}
\curso[o]{Curso de Bacharelado em Ciência da Computação}
%\documento[o]{TCC} % Opcional (Tese é o padrão)
\titulo{Análise da eficiência energética de algoritmos de criptografia baseados em curvas elípticas}
%\subtitulo{} % Opcional
\autor{Felipe de Azevedo Piovezan}
\grau{Bacharel em Ciência da Computação}
\local{Florianópolis - Santa Catarina} % Opcional (Florianópolis é o padrão) % chktex 8 
\data{02}{Dezembro}{2015}
\orientador[Orientador]{Prof.\ Dr.\ Luiz Cláudio Villar dos Santos}
\coorientador[Coorientador]{Prof.\ Dr.\ Daniel Santana de Freitas}
\coordenador[Coordenador]{Prof.\ Dr.\ Renato Cislaghi}

\numerodemembrosnabanca{5} % Isso decide se haverá uma folha adicional
\orientadornabanca{sim} % Se faz parte da banca definir como sim
\coorientadornabanca{sim} % Se faz parte da banca definir como sim
\bancaMembroA{Prof.\ Dr.\ Luiz Cláudio Villar dos Santos} %Nome do presidente da banca
\bancaMembroB{Prof.\ Dr.\ José Luís Almada Güntzel}      % Nome do membro da Banca
\bancaMembroC{Prof.\ Dr.\ Daniel Santana de Freitas}     % Nome do membro da Banca
%\bancaMembroD{Quarto membro}       % Nome do membro da Banca
%\bancaMembroE{Prof. quinto membro}       % Nome do membro da Banca
%\bancaMembroF{Prof. sexto membro}        % Nome do membro da Banca
%\bancaMembroG{Prof. sétimo membro}       % Nome do membro da Banca

\agradecimento{TBC}

\epigrafe{``Nevermore''}
{The Raven}

\textoResumo{A criptografia de chaves públicas (PKC), ou criptografia assimétrica, uma das bases para a comunicação segura pela internet, fornece as primitivas para a troca de chaves, autenticação de usuários e assinatura digital. A maioria dos algoritmos de PKC usados atualmente são baseados em conjecturas de teoria dos números, como a dificuldade da fatoração de inteiros ou a dificuldade de alguma versão do logaritmo discreto. Este último, quando usado na versão de curvas elípticas, permite o uso de chaves e assinaturas menores para o mesmo nível de segurança de outros algoritmos, o que é interessante em ambientes com recursos limitados.

	Durante o desenvolvimento dos algoritmos assimétricos, os principais nodos da rede eram grandes servidores e desktops. Recentemente, porém, a escala dos dispositivos que estabelecem comunicação segura pela internet está diminuindo consistentemente: dos laptops e celulares, até sensores e etiquetas RFID, todos necessitam de um canal seguro. Essa miniaturização, no entanto, veio acompanhada de restrições de processamento e de suprimento energético, o que conflita com o fato que algoritmos de PKC são computacionalmente caros: como, então, utilizá-los em ambientes com recursos limitados? O presente trabalho pretende, a partir de simulações, avaliar o gasto energético do sistema de memórias de processadores executando algoritmos de criptografia de curvas elípticas, bem como o impacto que técnicas de otimização têm na eficiência energética.
}

\palavrasChave{eficiência energética, criptografia, otimização de código}

\textAbstract{The realm of public-key (asymmetric) cryptography (PKC) is considered to be one the pillars of secure communication over the internet, since it includes user authentication, key exchange and digital signatures. PKC algorithms in use are mostly based in certain number-theoretic conjectures, like the difficulty of integer factorization or the difficulty of some discrete-log problem. The latter, when used in the elliptic curve setting, allows for shorter keys and signatures while maintaining the same security level of other algorithms, which is interesting in a resource constrained environment.
	
	During the development of the first asymmetric algorithms, most nodes in a network were either desktops or servers. Recently, however, the scale of the devices partaking in secure communations over the internet has been steadily decreasing: from laptops and cellphones to sensors and RFID tags, they all require a secure channel. This downscaling is responsible for new constraints on the processing power and battery supply available to each node, which directly conflicts with the fact that PKC algorithms are computationally expensive. What then is the best way to employ those algorithms in such constrained devices? By means of simulations, this work will evaluate the amount of energy spent in the memory system when processors execute elliptic curve algorithms, as well as the impact of certain code optimization techniques on energy efficiency.
}
\keywords{energy efficiency, cryptography, code optimization}

\begin{document}

%--------------------------------------------------------
% Elementos pré-textuais
%\capa  
\folhaderosto[comficha]
\folhaaprovacao% chktex 8 
\paginadedicatoria% chktex 8 
\paginaagradecimento% chktex 8 
\paginaepigrafe% chktex 8 
\paginaresumo% chktex 8 
\paginaabstract% chktex 8 
%\pretextuais % Substitui todos os elementos pre-textuais acima
\listadefiguras% as listas dependem da necessidade do usuário % chktex 8 
\listadetabelas% chktex 8 
\listadeabreviaturas% chktex 8 
\listadesimbolos% chktex 8 
\sumario% chktex 8 
%--------------------------------------------------------
% Elementos textuais

\chapter{Introdução}

Com a expansão da internet, não apenas servidores e \ingles{desktops} passam a fazer parte da rede, mas também um grande número de pequenos dispositivos como PDAs, celulares e sensores. Acoplados aos processadores de tais equipamentos, encontram-se transmissores de rádio que permitem a comunicação com outros dispositivos, estejam eles em uma rede local ou à longa distância conectados por algum \ingles{gateway}. Alguns problemas em comum podem ser encontrados nesses dispositivos, como limitações na capacidade de processamento, quantidade de memória e disponibilidade de bateria, além de estarem potencialmente expostos a diversos usuários maliciosos. O desafio, então, surge ao observar-se que a solução para a última deficiência entra diretamente em conflito com as primeiras.

Os protocolos utilizados para comunicação segura, sejam eles aqueles utilizados por browsers (como o TLS), por terminais (como o SSH) ou até mesmo em aplicações da internet das coisas (como~\cite{Resner:SENSORNETS:2015}), dependem de duas grandes classes de algoritmos criptográficos: os simétricos e os assimétricos. Embora as mensagens sejam cifradas com algoritmos simétricos, como o AES, o esbelecimento de um canal seguro é, de modo geral, iniciado com o uso da classe assimétrica, a qual permite a definição de um chave secreta conhecida apenas pelos participantes da conversa. Essa chave passa a ser utilizada pelo resto da sessão segura em algoritmos simétricos.

De modo geral, observa-se que algoritmos simétricos possuem implementações extremamente simples, podendo ser otimizados para diferentes configurações de processadores. É o caso do \ingles{Rijndael}~\cite{daemen1999aes}, vencedor da competição que elegeu o \ingles{Advanced Encryption Standard} (AES), cuja implementação pode ser feita executando-se operações matemáticas ou com o uso de \ingles{look-up tables} que variam de tamanho: 256 bytes, 1KB ou 4KB\@. Desse modo, permite-se a execução do AES em processadores com diferentes configurações de memória. Tamanha flexibilidade não ocorre por acaso: o algoritmo foi desenvolvido com esse objetivo, visto que a competição incluiu critérios como quantidade de memória requerida, eficiência computacional e simplicidade para avaliação dos candidatos~\cite{nechvatal2000report}.

Por outro lado, os algoritmos assimétricos possuem implementações complexas pela natureza do problema com que lidam: muitos deles estão associados ao uso de conjecturas da Teoria dos Números sob domínios de ordem muito grande, isto é, trabalham com conjuntos cuja cardinaliade precisa de centenas ou até milhares de bits para ser representada. Um dos algoritmos mais famosos dessa classe, o RSA, é baseado na dificuldade da fatoração de inteiros e trabalha com números na ordem de 1024 bits. Pode-se perceber, então, um dos possíveis inconvenientes que esse algoritmo traz: a aritmética de números desse tamanho não é trivial de ser implementada, principalmente se considerarmos que processadores utilizados em, por exemplo, redes de sensores trabalham com registradores de 8 ou 16 bits\footnote{É o caso do \ingles{Atmel ATmega} (8 bits) ou do \ingles{Texas Instruments MSP430} (16 bits)}.

Nesse cenário, as técnicas baseadas em curvas elípticas (ECC) mostraram-se muito interessantes por propiciarem um mesmo nível de segurança para um menor tamanho de chave. De acordo com~\cite{LenstraSelectingKeys}, a equivalência entre os tamanhos de chaves para as duas técnicas pode ser resumida na Tabela~\ref{tab:RSAxECC}. Pode-se notar que a diferença chega próxima de uma ordem de magnitude em muitos casos e, de fato, este é um dos argumentos utilizados pela RFC que adiciona algoritmos de ECC ao protocolo TLS~\cite{Blake-wilson06ellipticcurve}.

\begin{table}[h]
\centering
\begin{tabular}{cc}
\hline
ECC             & RSA             \\ \hline
163             & 1024            \\
233             & 2048            \\
283             & 3072            \\
409             & 7680            \\ \hline
\end{tabular}
\caption{Tamanho de chave (em bits) necessário para que os algoritmos ECC e RSA forneçam segurança equivalente~\cite{LenstraSelectingKeys}.}
\label{tab:RSAxECC}
\end{table}

Apesar de os algoritmos de ECC possibilitarem uma redução no tamanho das chaves, a implementação eficiente de criptografia de chaves públicas em ambientes com recursos limitados necessitou de muitos esforços da academia, conforme relatado por~\cite {Wenger:2013}. Tamanho investimento é justificado pelo crescente número de aplicações que executam em tais ambientes, como \ingles{smart cards}, redes de sensores sem fio ou etiquetas RFID\@. Para o caso de redes de sensores com processadores de 8 bits, apenas em 2004 demonstrou-se a viabilidade do uso de algoritmos de ECC em tais plataformas~\cite{first8bits:Gura}. De modo similar, a primeira implementação em hardware com consumo energético baixo o suficiente para ser alimentado passivamente foi demonstrada em 2008~\cite{Hein:2009}. Atualmente, diversos dispositivos médicos, como marcapassos, são configurados através de um canal sem fio e possuem longevidade de 5 a 15 anos. Nesse cenário, algoritmos de curvas elípticas são empregados por proverem a seguraça e eficiência necessárias~\cite{fan2013low}.


\section{Motivação e trabalho proposto}
Não é incomum em aplicações embarcadas que uma parcela considerável da computação seja efetuada por circuitos especializados, devido às demandas de desempenho e eficiência. De fato, segundo~\cite{Dally:2008}, um ASIC (\ingles{application-specific integrated circuit}) pode atingir uma eficiência de $5pJ/op$ na tecnologia CMOS de 90-nm. Por outro lado, processadores embarcados altamente eficientes atingem apenas $250 pJ/op$, uma perda de 50x. É evidente, então, a troca da flexibilidade de um processador de propósito geral pela eficiência propiciada por ASICs.

Nota-se, porém, que o tempo de projeto de um ASIC pode ser considerável e que muitas aplicações não se adequam à inflexibilidade propiciada por essa solução. Soluções flexíveis são necessárias em classes de problemas onde o desenvolvimento de novos algoritmos ou o surgimento repentino de uma demanda inesperada são comuns. Em criptografia, um exemplo de tal demanda pode ser a descoberta de um novo ataque a algum cifrador, o que poderia requerer o aumento de algum parâmetro, como tamanho de chave, ou até mesmo a troca por outro algoritmo, o que é facilitado em implementações via software. Pode-se citar um caso onde uma especificação de hardware não acompanhou a evolução de algoritmos criptográficos: em 2011, o conjunto de instruções ARMv8 para processadores ARM foi anunciado, trazendo instruções específicas para os algoritmos SHA1 e SHA2. O primeiro foi considerado inseguro e seu uso descontinuado a partir de 2010, enquanto o segundo já teve seu sucessor escolhido via competição em 2012~\cite{sha3}.

A busca por soluções eficientes em software para criptografia, então, não deve ser desconsiderada. Em se tratanto de eficiência energética em um processador embarcado, os fatores mais impactantes são ilustrados pela Figura~\ref{fig:energy_usage}. Observa-se que o fornecimento de dados e instruções pode requerer cerca de $70\%$ da energia total consumida, tornando-se alvos importantes para otimizações. Nota-se que a Figura~\ref{fig:energy_usage} refere-se ao consumo de energia nas memórias integradas junto ao processador (caches) e, essencialmente, independe da taxa de faltas (embora dependa do número de acessos e do tamanho das caches). Por outro lado, o consumo em memória principal (não computado na Figura 1) é bastante significativo e dependente da taxa de faltas nas caches. Isso motiva o uso de otimizações de código capazes de reduzir a taxa de faltas a níveis inferiores aos obtidos com a mera exploração de localidade espacial e temporal.

Com base nisso, o presente trabalho irá analisar o comportamento do sistema de memórias de um processador embarcado executando algoritmos de curvas elípticas, variando-se parâmetros do processador (como tamanho e associatividade das caches), parâmetros do algoritmo (como as curvas utilizadas e o tamanho de chaves) e aplicando-se técnicas de otimização voltadas à eficiência energética (como, por exemplo, pré-carga de instruções ou similar). Assim, será possível relacionar a influência de tais parâmetros no consumo de energia pelo sistema de memória.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/intro_energy_usage.png}
\caption{Consumo de energia em um processador embarcado~\cite{Dally:2008}}
\label{fig:energy_usage}
\end{center}
\end{figure}

O trabalho está dividido da seguinte maneira: o capítulo~\ref{ch:basic_crypto} define os conceitos básicos em criptografia e situa o contexto em que algoritmos de ECC são necessários, o capítulo~\ref{ch:correlatos} detalha os trabalhos correlatos. Na versão completa desta monografia, serão incluídos dois capítulos adicionais, um deles contendo os experimentos realizados, a metodologia adotada e resultados obtidos, o outro concluindo o trabalho e levantando possibilidades de trabalhos futuros.


\chapter{Conceitos Básicos em Criptografia}
\label{ch:basic_crypto}
Este capítulo pretende introduzir o leitor aos conceitos básicos de criptografia, iniciando por definições clássicas, seguido dos conceitos relacionados à criptografia simétrica. O material desta seção é baseado principalmente no trabalho de Goldreich~\cite{Goldreich:2006:FCV:1202577} e nas notas de aula do professor Charles Rackoff~\cite{Rackoff}, apresentando apenas uma síntese do conteúdo. O leitor interessado na bela teoria que suporta a criptografia é incentivado a consultar as referências indicadas. Embora não seja fundamental ao entendimento do resto deste trabalho, a primeira parte do capítulo é importante por situar o leitor no contexto em que a criptografia assimétrica é necessária.

Em seguida, o conceito de curva elíptica é apresentado, assim como operações necessárias à definição do logaritmo discreto. Um conhecimento básico de teoria de grupos é assumido, embora os conceitos mais importantes sejam revisados. Muitos dos exemplos e definições utilizados são baseados no anexo A do padrão IEEE 1363,~\cite{IEE1363}. Conclui-se o capítulo mostrando como todos os conceitos definidos podem ser combinados para formar um método seguro de troca de chaves, o que é conhecido como a versão de curvas elípticas de Diffie-Hellman, o qual é utilizado em todos os experimentos desse trabalho.

\section{Sessões seguras}
\label{sec:secure_sessions}
\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/crypto_model.png}
\caption{Modelo de uma sessão segura~\cite{Rackoff}}
\label{fig:crypto_model}
\end{center}
\end{figure}

A aplicação mais tradicional de criptografia, aquela descrita por um usuário comum de informática, encontra-se no estabelecimento de \keyword{sessões seguras} (\ingles{secure sessions}). Isto é, duas pessoas, $A$ e $B$, tendo um segredo em comum (daqui em diante chamado de \keyword{chave}), gostariam de se comunicar através de um canal potencialmente inseguro. Com alguma frequência, $A$ gostaria de mandar algo\footnote{Tratamos de comunicação unidirecional aqui por simplicidade, todos os conceitos podem ser expandidos para um canal bidirecional.} (\keyword{texto em claro}, \ingles{plaintext}) para $B$; denotar-se-á por \keyword{mensagem} tudo aquilo que $A$ gostaria de enviar para $B$, embora $A$ esteja restrito a enviar uma fração de tal mensagem por vez. Considera-se também a existência de um adversário $ADV$ computacionalmente irrestrito, limitado a ouvir tudo que $A$ envia pelo canal. Informalmente, $A$ gostaria de cifrar a mensagem de modo que $ADV$ não possa descobrir nenhuma informação sobre a mesma.


Tal cenário é representado pela figura~\ref{fig:crypto_model} e motiva a primeira definição aqui apresentada:

\begin{definicao}
    Define-se que uma chave é um $K \in \{0,1\}^n$, onde $K = K_1K_2\dots K_n$, e uma mensagem é um $M \in \{0,1\}^m$, onde $M = M_1M_2\dots M_m$\footnote{A notação $\{0,1\}^n$ representa uma string de exatamente $n$ caracteres do conjunto $\{0,1\}$, enquanto $\{0,1\}^*$ denota uma string de caracteres desse mesmo conjunto, porém de tamanho arbitrário}.
\end{definicao}

Pode-se, então, definir uma função responsável por mapear uma mensagem e uma chave para uma nova string, a qual espera-se que seja ``aleatória'' (uma definição precisa para esse termo será dada adiante). De modo similar, precisa-se de uma função que desfaça o trabalho da primeira, isto é, uma função que receba a string ``aleatória'' junto com a chave utilizada para gerá-la e produza a mensagem original. Tais idéias são capturas pelas seguintes definições:

\begin{definicao}
Uma \ingles{encryption function} é uma função \[Enc: \{0,1\}^m \times \{0,1\}^n \to \{0,1\}^*\]

Uma \ingles{decryption function} é uma função \[Dec: \{0,1\}^* \times \{0,1\}^n \to \{0,1\}^m\]

Requer-se do par $(Enc, Dec)$ a seguinte \keyword{condição de corretude}: \[\forall M \in \{0,1\}^m,  \forall K \in \{0,1\}^n Dec(Enc(M, K), K) = M\]
\end{definicao}

Informalmente, $Enc(M,K)$ é entendida como a mensagem $M$ cifrada que $A$ envia a $B$, o qual aplica $Dec$ para retornar ao texto em claro. É importante insistir na condição de corretude, uma vez que ela garante que qualquer mensagem cifrada por $Enc$ será corretamente produzida por $Dec$, desde que a mesma chave seja usada em ambas as funções\footnote{É comum nos referirmos ao par $(Enc, Dec)$ quando queremos discutir alguma propriedade criptográfica, visto que as duas funções geralmente estão relacionadas para conferir corretude. É um exercício interessante pensar como seria fácil obter segurança sem o requerimento de corretude.}.

Pode-se agora descrever o que seria uma função segura. Informalmente, $A$ e $B$ escolheram de algum modo uma chave aleatória $K$, a qual foi utilizada para transmitir uma mensagem (cifrada) de $A$ para $B$ através de um canal inseguro. Idealmente, um adversário que queira descobrir a mensagem original, tendo visto o que foi enviado pelo canal e dispondo de quanto tempo quiser, não ganha nenhuma informação sobre a mesma. Isto é, sua melhor estratégia ainda consiste em fazer um palpite aleatório. Formalmente, diz-se que:

\begin{definicao}
O par $(Enc, Dec)$ é dito \keyword{perfeitamente seguro} se, para toda $f:\{0,1\}^* \to \{0,1\}^m$, a seguinte proposição é válida:

Considere o experimento em que $M$ é escolhida de modo aleatório de $\{0,1\}^m$ e $K$ é escolhida de modo aleatório de $\{0,1\}^n$. Então deve ser  verdade que: \[P[f(Enc(M,K)) = M] = 1/2^m\]
\end{definicao}

Note que o fato do adversário estar ilimitado computacionalmente é representado pelo fato de que ele é modelado como uma função arbitrária na definição.
 
No caso em que $n > m$, é possível criar um par $(Enc, Dec)$ perfeitamente seguro: as funções $Enc(M,K) = M_1 \oplus K_1 M_2 \oplus K_2 \dots M_m \oplus K_m$ e $Dec(X,K) = X_1 \oplus K_1 X_2 \oplus K_2 \dots X_m \oplus K_m$ satisfazem a definição\footnote{Tal função é conhecida como \ingles{one-time pad} na literatura.}. Na prática, porém, essa definição não é muito interessante, visto que gostaríamos de trabalhar com chaves pequenas (algumas centenas de bits) e mensagens de tamanho arbitrário\footnote{Embora o termo arbitrário seja utilizado, na prática espera-se que esse número seja muito inferior a $2^n$}. Essa necessidade entra diretamente em conflito com o seguinte teorema:

\begin{teorema}
Se $m > n$, isto é, se o tamanho da chave for superior ao tamanho da mensagem, então nenhum $(Enc, Dec)$ é perfeitamente seguro.
\end{teorema}

A prova, embora simples, é omitida por estar fora do escopo do trabalho e pode ser consultada nas referências indicadas. Para contornar esse teorema poderoso, adicionaremos a restrição de que o adversário deve ser um algoritmo o qual executa em tempo polinomial (em relação a $n$), isto é, ele possui um tempo consideravalmente limitado para executar. Com esta restrição adicional, pode-se criar algoritmos (geradores de função) que, dado um chave, produzam uma função capaz de mapear mensagens para strings de modo aleatório, sem permitir que tais adversários limitados possam descobrir algo sobre a chave. A definição formal dessa idéia é um tanto complexa, e é apresentada aqui para o leitor interessado.

\begin{definicao}
Um \keyword{gerador de funções} (\ingles{Function Generator}) $F$ associa a cada $n\in\mathbb{N}$ e a cada $k \in \{0,1\}^n$ uma função $F_k: \{0,1\}^n \to \{0,1\}^n$ de modo que exista um algoritmo com tempo de execução polinomial (em $n$) o qual compute $F_k(x)$.

Um gerador de funções é \keyword{pseudo-aleatório} se um adversário não consegue distinguir entre um $F_k$ (para um $k$ escolhido aleatoriamente) e uma função $f:\{0,1\}^n \to \{0,1\}^n$ escolhida aleatoriamente  com probabilidade superior a $1/n^c$ para todo $c$ e para $n$ suficientemente grande.
\end{definicao}

Assume-se que os algoritmos $AES$ e $DES$ se comportem como geradores de funções pseudo-aleatórios\footnote{Um pequeno abuso é feito nessa afirmação, visto que esses algoritmos são definidos para alguns poucos valores de $n$.}. O primeiro, por exemplo, associa uma chave $k$ de 128 (196 ou 256) bits com a função $AES_k$ e é esta função que $A$ tipicamente usa para enviar sua mensagem para $B$. De fato, esses algoritmos são construídos de modo que as funções geradas sejam também permutações, permitindo que se utilize $Enc = AES_k$ e $Dec = AES^{-1}_k$. A razão pela qual simplesmente \emph{assumimos} que geradores de função pseudo-aleatórios existam é devido ao fato dessa ser uma afirmação mais forte que $P \not= NP$, e somos incapazes de provar isso. De fato, uma condição necessária para a segurança de toda a criptografia moderna é que $P \not= NP$, embora essa não seja uma condição suficiente.\footnote{O leitor intrigado por essa observação pode notar que não basta ser difícil quebrar um sistema criptográfico no pior caso, e é essa noção que é capturada pelo problema $P \not= NP$. É possível construir um sistema criptográfico para o qual o problema de distinguir $Enc$ é NP-Completo, embora exista um algoritmo eficiente que o resolva em $99\%$ dos casos~\cite{Goldreich:2006:FCV:1202577}.}


\section{Curvas Elípticas}
Até esse momento, assumiu-se que $A$ e $B$ haviam previamente combinado uma chave para efetuar a comunição segura. Tal hipótese pode ser suficiente para ambientes em que poucos pares precisam se comunicar, porém não é adequada para a maioria dos outros cenários. Essa observação motiva o principal objetivo da criptografia assimétrica: como fazer com que duas pessoas possam trocar alguns poucos parâmetros através de um canal inseguro e, ao final da comunicação, ambas compartilhem uma mesma chave desconhecida a qualquer adversário manipulando o canal?

Atualmente, esse objetivo é atingido com o uso de algumas conjecturas da teoria dos números. Uma delas é a dificuldade (de alguma versão) do problema do logaritmo discreto. Neste trabalho, estamos interessados na variação de curvas elípticas do problema, o assunto da presente seção. Definir-se-á o significado de uma curva elíptica, bem como operações que podem ser realizadas em seus elementos e, por fim, o que é o logaritmo discreto neste contexto.

Uma curva elíptica será definida como um conjunto de pontos com algumas propriedades. Ao contrário de pontos habituais, porém, as coordenadas dos pontos da curva não são número reais, mas sim inteiros de um certo conjunto, com algumas operações e propriedades. Esse tipo de conjunto é definido a seguir.

\begin{definicao}
    Um conjunto $F$ com um elemento $0$ e duas operações binárias $+$ e $\cdot$ é um \keyword{corpo finito} (\ingles{finite field}, ou \ingles{Galois field}) se as seguintes condições forem verdadeiras:
    \begin{enumerate}
        \item $F$ é um conjunto finito
        \item $+$ é uma operação associativa
        \item $+$ é uma operação comutativa
        \item $0$ é o elemento neutro de $+$
        \item Cada elemento de $F$ possui um inverso para $+$ em $F$
        \item $\cdot$ é uma operação associativa
        \item $\cdot$ é uma operação comutativa
        \item Distributividade de $\cdot$ em relação a $+$ (à esquerda e à direita)
        \item Existência de um elemento neutro ($1$) para $\cdot$
        \item Todo elemento de $F$ diferente de $0$ possui uma inversa para $\cdot$ em $F$
    \end{enumerate}
\end{definicao}

O leitor certamente está habituado com tais conjuntos: os números reais com as operações de soma e multiplicação habituais satisfaz a definição, exceto pela primeira condição. Um outro conjunto menos conhecido, o qual será utilizado nos conceitos de curvas elípticas, também possui todas as propriedades necessárias:

\begin{definicao}
    Dado um número primo $p$, o conjunto dos números inteiros módulo $p$ com as operações habituais de soma e multiplicação módulo $p$ é um corpo finito, denotado $GF(p) = \{0, 1, \ldots, p-1\}$.
\end{definicao}

Menciona-se que, para um primo $q$ e um inteiro positivo $n$, pode-se definir um corpo finito $GF(q^m)$ com o uso de polinomiais, embora sua definição precisa seja omitida por estar fora do escopo deste trabalho. Está observação é importante pois tal conjunto pode ser usado como alternativa à $GF(p)$ em curvas elípticas. Dado um desses conjuntos, os pontos de uma curva elíptica possuem duas coordenadas ($x$ e $y$), ambas em tal conjunto. Além disso, $x$ e $y$ estão relacionados por algum equação, conforme a definição a seguir.Por razões discutidas mais adiante, será interessante poder somar dois pontos, o que requer um ponto especial que funcione como o zero da adição, chamado de ponto no infinito.

\begin{definicao}
Uma curva elíptica $E$ sobre o corpo finito $GF(p)$, onde $p$ é um número primo ímpar, é o conjunto: 
\begin{align*} 
	E = \{ (x,y) \quad | \quad &y^2 = x^3 + ax + b \\
							   &\wedge\quad x, y, a, b \in GF(p) \\
							   &\wedge\quad 4a^3 + 27b^2 \not= 0\; (mod \;p) \} \cup \{ O\}
\end{align*}
	
	onde $a$ e $b$ são constantes relacionadas a curva e $O$ é chamado de ponto no infinito.
\end{definicao}

Pode-se também criar uma curva elíptica sobre $GF(2^m)$, cuja definição é dada a seguir, embora os demais conceitos desse capítulo sejam tratados apenas para o caso de $GF(p)$ para evitar demasiadas repetições. É importante lembrar, porém, que a escolha do corpo tem implicações tanto no modo como seus elementos são representados em memória como na definição de operações e algoritmos. 

\begin{definicao}
Uma curva elíptica $E$ sobre o corpo finito $GF(2^m)$, é o conjunto: 
\begin{align*} 
	E = \{ (x,y) \quad | \quad &y^2 + xy = x^3 + ax^2 + b \\ 
							   &\wedge\quad x, y, a, b \in GF(2^m) \quad\wedge\quad b \not= 0\} \cup \{ O\}
\end{align*}

	onde $a$ e $b$ são constantes relacionadas a curva e $O$ é chamado de ponto no infinito.
\end{definicao}

O tamanho do conjunto que define a curva será importante a diante, portanto recebe um nome especial.

\begin{definicao}
	O número de elementos de uma curva elíptica $E$ é chamado de \keyword{ordem} de $E$ e é denotado por $\#E(GF(q))$.
\end{definicao}

Para ilustrar as definições, considere a curva $E$ dada por \[y^2 = x^3 + x + 5\] sobre $GF(13)$. Os pontos de $E$ são:
\[ \{O, (1,4), (1,9), (3,6), (3,7), (8,5), (8,8), (10,0), (11,4), (11,9) \} \]

Além disso, $\#E(GF(13)) = 10$.


A figura~\ref{fig:ecc_example_overGF} ilustra os pontos da curva sobre $GF(13)$ e, para comparação, a mesma curva é desenhada sobre os reais na figura~\ref{fig:ecc_example_overR}. Como se pode observar, a troca de domínio muda consideravelmente a aparência da curva.
%Dá uma olhada na matplotlib   /numpy

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/ecc_example_overGF.png}
\caption{Conjunto de pontos que representa uma curva elíptica sobre $GF(13)$}
\label{fig:ecc_example_overGF}
\end{center}
\end{figure}


\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/ecc_example_overR.png}
\caption{Conjunto de pontos que representa uma curva elíptica sobre $\mathbb{R}$}
\label{fig:ecc_example_overR}
\end{center}
\end{figure}

	Os próximos parágrafos são destinados a definir uma operação de soma ($+$) para pontos de uma curva elíptica, o que viabilizará a definição de um problema conhecido como o logaritmo discreto em curvas elípticas. Tal problema é o cerne da criptografia de curvas elípticas, portanto merece uma explicação detalhada.
    
    Intuitivamente, tem-se que a soma de dois pontos $P_1 + P_2$ é o ponto $P_3$ com a propriedade que $P_1$, $P_2$ e $-P_3$ são colineares. Para um ponto $P = (x, y)$, define-se $-P = (x, -y)$. Por clareza, este trabalho define a soma de dois elementos de $E$ para o caso de $GF(p)$ através do algoritmo \proc{Soma}, conforme~\cite{IEE1363}. 
    
    As linhas~\ref{li:sum-zero-begin}--~\ref{li:sum-zero-end} tratam o ponto no infinito, $O$, como o elementro neutro da operação. No caso em que os pontos não possuam a mesma coordenada $x$, as linhas~\ref{li:sum-lambda1-begin}--~\ref{li:sum-lambda1-end} calculam o coeficiente angular da reta secante que passa por $P_1$ e $P_2$, enquanto calcula-se o coeficiente da reta tangente a curva em um dos pontos quando $P_1 = P_2$ (linha~\ref{li:sum-lambda2}). Caso os pontos difiram apenas na coordenada $y$, então temos $P_1 = -P_2$ e o algoritmo retorna o elemento neutro (linhas~\ref{li:sum-sumzero-begin}--~\ref{li:sum-sumzero-end}). Por fim, as linhas~\ref{li:sum-final-begin}--~\ref{li:sum-final-end} utilizam o coeficiente mencionado anteriormente para calcular as coordenadas de $P_3$.

	Note que, embora termos como coeficiente angular e reta tangente sejam utilizados, os quais estão normalmente relacionados a funções sobre o domínio dos reais, o algoritmo opera sobre $GF(p)$, logo todas as operações de soma, subtração, multiplicação ou divisão que aparecem no algoritmo \proc{Soma} devem ser realizadas $mod\; p$. Isso ilustra uma das primeiras dificuldades de implementação de algoritmos relacionados a curvas elípticas: as operações de multiplicação e inversão em $GF(p)$ não são triviais.

    \begin{codebox}
	\label{alg:sum_over_ECC}
    \Procname{$\proc{Soma}(P_1, P_2)$}
	\li \If $P_1 = O$ 			\label{li:sum-zero-begin}
	\Do
		\li output $P_2$ and stop. 
	\End
	\li \If $P_2 = O$ 
	\Do
		\li output $P_1$ and stop. 
	\End						\label{li:sum-zero-end}
	\li Set $x_1 \gets P_1.x$
	\li Set $y_1 \gets P_1.y$
	\li Set $x_2 \gets P_2.x$
	\li Set $y_2 \gets P_2.y$
	\li \If $x_1 \not= x_2$ 	\label{li:sum-lambda1-begin}
	\Do	
		\li Set $\lambda \gets (y_1 - y_2)/(x_1 - x_2)$ \label{li:sum-lambda1-end}
	\li \Else
	\li \If $y_1 \not= y_2$ or $y_2 = 0$ \label{li:sum-sumzero-begin}
		\Do
			\li Output $O$ and stop.
		\End							\label{li:sum-sumzero-end}
		\li Set $\lambda \gets (3{x_2}^2 + a)/(2y_2)$	\label{li:sum-lambda2}
	\End
	\li Set $x_3 \gets \lambda^2 - x_1 - x_2 \quad mod\; p$		\label{li:sum-final-begin}
	\li Set $y_3 \gets (x_2 - x_3)\lambda - y_2 \quad mod\; p$	\label{li:sum-final-end}
	\li output $(x_3, y_3)$
    \end{codebox}



    Com isto em mente, a intuição dada pelo domínio real ajuda a visualizar a soma em $GF(p)$, onde a idéia de colinearidade ainda pode ser representada graficamente para fins didáticos. Utilizando a mesma curva do exemplo anterior, a figura~\ref{fig:ecc_example_addition} ilustra \emph{informalmente} a adição dos pontos $P_1 = (10,0)$ e $P_2= (8,5)$. Primeiro, a reta que sai de $P_1$ e passa por $P_2$ é traçada. Quando esta reta atinge os limites do gráfico, isto é, uma de suas coordenadas atinge o valor $13$ (ou $0$), pode-se entender que a operação de módulo é aplicada (note que a operação de módulo é aplicada apenas na coordenada que atingiu um valor inteiro), efetivamente continuando a reta no lado oposto do gráfico. Tal procedimento é repetido até que um ponto de $E$, aqui chamado de $-P_3$, seja encontrado, de modo que $P_1$, $P_2$ e $-P_3$ sejam colineares. A soma de $P_1$ e $P_2$ é dada então por $P_3$. Note ainda que, caso dois pontos tenham a mesma coordenada $x$, a reta que passa por ambos está na vertical e, portanto, nunca tocará um terceiro ponto de $E$ que não seja o ponto no infinito, $O$.


\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.50]{images/ecc_example_addition.png}
\caption{Somando pontos em uma curva elíptica sobre $GF(13)$}
\label{fig:ecc_example_addition}
\end{center}
\end{figure}

Algebricamente, teríamos que:

\begin{align*} 
	\lambda &= (y_1 - y_2) / (x_1 - x_2) \quad mod\; p\\
			&= (0 - 5) / (10 - 8) \quad mod\; 13\\
			&= -5 / 2  \quad mod\; 13 \\
			&= 8 * 7 \quad mod\; 13 \\
			&= 4
\end{align*}

\begin{align*} 
	x_3 &= \lambda ^2 - x_1 - x_2 \quad mod\; p \\
		&= 4^2 - 10 - 8 \quad mod \; 13 \\
		&= 11
\end{align*}
	
\begin{align*} 
	y_3 &= (x_2 - x_3)\lambda -y_2 \quad mod\; p \\
		&= (8-11)4 - 5 \quad mod \; 13 \\
		&= 9
\end{align*}

O que é equivalente às coordenadas de $P_3$ obtidas geometricamente.

Como consequência da operação de adição, pode-se definir a multiplicação de um ponto por um escalar, exatamente como se faz com inteiros: através de somas sucessivas. Se $k \in \mathbb{Z}$ e $P \in E$, então: 

 \begin{displaymath}
   kP = \left\{
     \begin{array}{lr}
       $O$ & : k = 0\\
       $(-k)(-P)$ & : k < 0 \\
       $P + (k-1)P$ & : k > 0
     \end{array}
   \right.
\end{displaymath} 

Um observação importante é a de que, dado um ponto da curva, pode-se somá-lo repetidamente até que o elemento neutro $O$ seja obtido. Isto acontece para qualquer ponto da curva e a quantidade de adições realizadas recebe um nome especial.

\begin{definicao}
A \keyword{ordem} de um ponto $P$ em uma curva elíptica $E$ é o menor inteiro positivo $r$ tal que \[rP = O\]
\end{definicao}

Representa-se o conjunto formado pela repetida soma de um ponto $P$ como $\langle P \rangle = \{0, P, 2P, \dots (n-1)P\}$. Note que este é um conjunto finito.

De um resultado encontrado na Álgebra, tem-se que a ordem de um ponto sempre existe e divide a ordem da curva, $\#E(GF(p))$. Além disso, se $k$ e $l$ são inteiros, então $kP = lP$ se, e somente se, $k \equiv l \quad mod\; p$.

Pode-se agora definir o logaritmo discreto de um ponto em uma curva elíptica, porém é interessaante refletir sobre o logaritmo tradicional primeiro: enquanto $log_b x$ responde a pergunta de quantas vezes $b$ deve ser \textbf{multiplicado} por ele mesmo até que se encontre $x$, o logaritmo discreto de $P$ em relação a $G$ trabalha com quantas vezes precisa-se \textbf{somar} $G$ até que se encontre $P$. Enquanto no logaritmo tradicional essa pergunta está sempre bem definida (e possui resposta) para valores positivos de $b$ e $x$, o leitor pode se perguntar se o mesmo é válido para todos os valores de $G$ e $P$. A resposta é negativa, embora existam condições o envolvendo os conceitos de ordem de ponto as quais permitem resposta afirmativa.

\begin{definicao}
	\label{def:logdiscreto}
Suponha que um ponto $G$ em uma curva $E$ tenha ordem $r$, onde $r^2$ não divida a ordem da curva $\#E(GF(p))$. Então um ponto $P$ satisfaz $P = lG$ para algum $l$ se, e somente se, $rP = O$. O coeficiente $l$ é chamado de \keyword{logaritmo discreto} de $P$ em relação ao ponto base $G$.
\end{definicao}

Em termos de um problema computacional, a formulação mais tradicional é dada a seguir~\cite{CryptoEncyc}:

\begin{definicao}
	Considere uma curva elíptica $E$ e um ponto $P\in E$ de ordem $n$. Dado um ponto $Q \in \langle P \rangle = \{0, P, 2P, \dots (n-1)P\} $, o \textbf{problema do logaritmo discreto sobre curvas elípticas} (ECDLP) consiste em computar $0 \leq l \leq n-1$ tal que $Q = lP$.
\end{definicao}

O algoritmo ingênuo para resolver uma instância de ECDLP consiste em computar os múltiplos de $P$ (isto é, os membros de $\langle P \rangle$) até que se encontre $Q$, o que pode levar até $n$ adições, impraticável para valores muito altos de $n$. Atualmente, os melhores algoritmos conhecidos são baseados em variações do método \ingles{Pollard's $\rho$} e executam em tempo $O(\sqrt{n})$~\cite{Pollard1}\cite{Pollard2}.

\section{\ingles{Elliptic Curve Diffie Hellman}}
O leitor deve lembrar o cenário em que a seção~\ref{sec:secure_sessions} foi encerrada: $A$ e $B$ conseguem se comunicar de modo seguro dado que possuam uma chave secreta em comum. É exatamente esta pré-condição que será discutida a seguir, e não deve causar surpresa que o uso do ECDLP será crucial nessa tarefa.

Em 1976,  Whitfield Diffie e Martin Hellman publicaram um método para a troca de chaves em um canal inseguro~\cite{DiffieHellman} o qual é baseado no problema do logaritmo discreto de inteiros em $GF(p)$. Embora não forneça autenticação (isto é, $A$ não possui garantias de que está de fato conversando com $B$\footnote{Nenhum dos protocolos apresentados aqui possuirá essa característica, visto que é algo difícil de ser alcançado sem uma Infraestrutura de Chaves Públicas (\ingles{Public Key Infrastructure}) previamente estabelecida. Atualmente, isto é feito através de certificados e autoridades certificadoras. Ainda assim, tais protocolos são realistas e são utilizados em versões autenticadas dos mesmos.}), ele é a base de protocolos com autenticação. Pouco tempo depois, em 1978, a dificuldade da fatoração de números inteiros foi utilizada por R.L. Rivest, A. Shamir, e L. Adleman para atingir o mesmo propósito, no algoritmo conhecido como $RSA$~\cite{Rivest:1978:MOD:359340.359342}. Em 1985, dois autores propuseram independentemente o uso de curvas elípticas para a troca de chaves (\cite{koblitz1987elliptic},~\cite{Miller}) com tais métodos se popularizando a partir de 2004\footnote{Mais recentemente, as pesquisas em algoritmos baseados em Retículos (\ingles{Lattices}) ressurgiram, visto que essa é uma classe de algoritmos resistentes a ataques por computadores quânticos, ao contrário daqueles baseados em Diffie-Hellman e RSA. }.

Descreve-se aqui um dos protocolos padronizados em~\cite{IEE1363}, lá referenciado por DL/ECKAS-DH1, ou \ingles{Discrete Logarithm and Elliptic Curve Key Agreement Scheme, Diffie-Hellman version}. $A$ e $B$ devem executar os seguintes passos para o estabelecimento de uma chave:

\begin{enumerate}
	\item Em comum acordo, estabelecer um conjunto de parâmetros do domínio a ser trabalhado: os coeficientes $a$ e $b$ da curva, o número primo $p$ e um ponto $G$ de ordem $r$.
	\item Cada uma das partes escolhe um número inteiro aleatório $s$ no intervalo $[1, r-1]$ e computa o ponto $W = sG$. $s$ e $W$ são chamados de chave privada e pública, respectivamente.
	\item Obter da outra parte a chave pública dela, $W'$.
	\item Cada parte pode computar $P = sW' = (x_P, y_P)$. $x_P$ será considerado o segredo compartilhado.
	\item Aplicar uma função de derivação de chave sobre $x_P$.
\end{enumerate}

As etapas, embora simples, merecem diversas considerações adicionais. Os parâmetros de domínio não podem ser gerados de forma totalmente aleatória: diversas curvas anômalas precisam ser evitadas por permitirem a simplificação do ECDLP, assim como impõe-se restrições sobre a fatoração de $r$ para evitar o mesmo problema. Tipicamente, utilizam-se parâmetros pré-estabelecidos por padrões, como as curvas padronizadas pelo NIST (\ingles{National Institute of Standards and Technology})~\cite{Barker:2007:SRP:2206270}\footnote{Essas curvas foram escolhidas, em teoria, por possuírem características adequadas para o ECDLP e por permitirem implementações eficientes das operações de grupo. Existem, no entanto, algoritmos para gerar parâmetros seguros caso o uso de curvas estabelecidas por organizações seja um inconveniente.}.

Ao receber de $B$ o valor $W'$, $A$ pode utilizar o critério da definição~\ref{def:logdiscreto} para verificar que $W'$ é, de fato, um múltiplo de $G$. Nota-se também que, até esse momento, todas as mensagens foram trocadas em um canal inseguro: qualquer adversário pode ter acesso aos parâmetros de domínio, bem como a $W$ e $W'$ (o primeiro é enviado por $A$ para $B$ e o segundo por $B$ para $A$). Porém apenas $A$ e $B$ conseguem computar facilmente o valor $P = sW' = s'W = ss'G$, assumindo que o problema ECDLP seja, de fato, difícil. Por fim, aplica-se alguma função sobre o valor $x_P$ para gerar uma string $k$ de tamanho apropriado, a qual será utilizada em funções como o $AES_k$.

\chapter{Trabalhos Correlatos}
\label{ch:correlatos}

Os trabalhos relacionados a investigar a viabilidade e a eficiência energética de algoritmos de ECC podem ser divididos em dois grandes conjuntos: os voltados a processadores com cache e os voltados a processadores em cache. Tais conjuntos são os temas dos capítulos~\ref{ch:com_cache} e~\ref{ch:sem_cache}.

\section{Trabalhos voltados a processadores com cache}
\label{ch:com_cache}
As primeiras publicações as quais investigaram a performance de sistemas de criptografia baseados em curvas elípticas possuiam um grande enfoque em tempo de execução. Em~\cite{Hankerson}, realizou-se um levantamento extensivo de diversas implementações para as operações aritméticas em $GF(2^m)$, assim como algoritmos para multiplicação por escalar em curvas, e o tempo de execução em um processador de desktop da época foi reportado.~\cite{Aydos} apresentaram uma biblioteca para um processador ARM de 32 bits com operações para curvas em $GF(p)$, reportando tempo de execução para o ECDSA (\ingles{Elliptic Curve Digistal Signature Algorithm}), o qual utiliza as mesmas primitivas que ECDH.

O trabalho de~\cite{Bartolini}, a partir do simulador Superscalar para a arquitetura ARM, foi o primeiro a reportar dados do comportamento do sistema de memória para algoritmos de ECC, embora para uma única configuração de cache. Além disso, encontram-se dados sobre CPI e tempo de execução por procedimento do algoritmo, bem como a proposta de uma instrução para multiplicação de polinomiais e o impacto que isso teria no algoritmo. Tal proposta é interessante visto que, anos depois, o conjunto de instruções ARMv8 trouxe uma instrução similar, embora não se encontrou nenhuma técnica utilizando ela na prática.

Em uma continuação desse trabalho,~\cite{Branovic} realizaran uma análise da distribuição dos tipos de instrução executadas pelo algoritmo, onde pode-se observar que instruções de ALU totalizam $60\%$ do total de executadas (Figura~\ref{fig:instruction_classes}), resultado confirmado pelos trabalhos de~\cite{Gouvea} e~\cite{Gura}. Outra contribuição consiste na comparação do \ingles{miss rate} entre algoritmos simétricos e assimétricos, onde pode-se observar que os algoritmos de ECC possuem uma taxa de faltas na cache de dados muito inferior quando comparados ao AES (figura~\ref{fig:cache_ecc_aes} à direita), embora detalhes da implementação deste não sejam reportados. Além disso, a diferença entre o \ingles{miss rate} na cache de dados e na de instruções (para os algoritmos de ECC) chega a uma ordem de magnitude, conforme a figura~\ref{fig:cache_ecc_aes}.

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.40]{images/instruction_classes.png}
\caption{Distribuição dos tipos de instruções executadas durante algoritmos de ECC (segunda e terceira colunas) \cite{Branovic}}
\label{fig:instruction_classes}
\end{center}
\end{figure}

\begin{figure}[ht]
\begin{center}
\includegraphics[scale=0.33]{images/cache_ecc_aes.png}
\caption{Comparação entre os acertos em cache dos algoritmos de ECC (colunas ec-dh) e AES (colunas rj) \cite{Branovic}}
\label{fig:cache_ecc_aes}
\end{center}
\end{figure}

Como mostra a Figura~\ref{fig:instruction_classes}, a proporção das instruções que corresponde a desvios é bastante baixa (menos de $10\%$). Ora, isso significa que o tamanho médio dos blocos básicos é de 10 instruções (sucessivas), o que resulta em um grande potencial de captura de localidade espacial pelo mero uso de busca sob demanda (on-demand fetching), mecanismos clássico embutido na maioria dos controladores de cache. Portanto, técnicas que reorganizem o código para aumentar sua localidade espacial parecem ter pouco potencial de impacto mesmo para caches de instruções com mais de, digamos, 8 palavras por bloco. Como, para caches de dados, a Figura~\ref{fig:cache_ecc_aes} mostra uma taxa de faltas que é uma ordem de magnitude inferior à da cache de instruções, técnicas de otimização baseadas no aumento da localidade espacial de dados seriam inócuas. Como a melhor captura de localidade temporal requereria o uso de caches com maior associatividade, a redução do consumo em memória principal (devido à redução da taxa de faltas) provocaria um aumento do consumo em cache (devido à maior associatividade). Este raciocínio mostra que o impacto energético em cache ao executar algoritmos baseados em curvas elípticas merece uma investigação experimental para uma ampla faixa de parâmetros compatível com a classe de aplicações alvo (dispositivos pessoais móveis). Ademais, o desafio de economizar energia em algoritmos baseados em curvas elípticas parece residir em técnicas de otimização que busquem reduzir a taxa de faltas sem buscar aumentar a localidade espacial para um dado grau de associatividade. Um exemplo de técnica com esse potencial é a pré-carga de instruções por software (software prefetching)~\cite{EmilioDAC}.


\section{Trabalhos voltados a processadores sem cache}
\label{ch:sem_cache}

Outro conjunto de trabalhos passa a focar em processadores utilizados em sensores, como~\cite{Gura}, o qual comparou o tempo de execução, uso de memória e tamanho do código para os algoritmos RSA e ECC em um ATmega128. As conclusões apresentadas em tal trabalho indicam que os algoritmos baseados em RSA podem ser até uma ordem de magnitude mais lentos, embora espere-se que essa diferença seja menor para processadores com tamanho de palavra maior. Uma implementação detalhada para plataforma de sensores MICA, a qual utiliza o processador ATmega128, é descrita em~\cite{Wang}, embora não sejam informados dados de eficiência enérgica. Um trabalho por~\cite{Gouvea} compara esquemas de ECC com esquemas baseados em identidades e pareamentos, onde conclui-se que os primeiros possuem um desempenho superior. Uma segunda contribuição do trabalho consiste em demonstrar a importância do uso apropriado de otimizações voltadas a arquitetura alvo, visto que os autores foram os primeiros a considerar a instrução de \ingles{multiply and accumulate} do processador MSP430 ao desenvolverem sua implementação. Nessa mesma plataforma,~\cite{Mane} reporta o consumo energético ao variar-se a frequência operada bem como a presença de multiplicador em hardware, atributo o qual não está presente em todas as versões do MSP430.

Quatro anos após a prova em silício de que algoritmos de ECC podem ser utilizados em RFID~\cite{Hein:2009}, apresentou-se uma implementação em software para a plataforma RFID conhecida como WISP~\cite{Pelnar}. Neste trabalho, apenas a menor curva padronizada pelo NIST é utilizada, reportando tempo de execução de 1.6 segundos para multiplicação de um ponto da curva por um escalar.

O trabalho de~\cite{deClerc} avalia o uso de curvas elípticas com o recém lançado processador Cortex M0+ da ARM (32 bits), propondo um novo algoritmo para multiplicação em $GF(q)$. Além disso, o custo enérgico de cada instrução executada pelo processador é avaliado e o desempenho dos algoritmos criptográficos calculado com base em tais valores. Infelizmente, o trabalho se concentra em curvas especiais e não naquelas padronizadas. De modo similar,~\cite{Liu} explora duas formas especiais de curvas elípticas (\ingles{Montgomery} e \ingles{Twisted Edwards}) bem como a equivalência existente entre elas para diminuir o custo das operações de grupo. A importância do uso de curvas padronizadas é discutida em~\cite{Wenger}, onde os autores desenvolvem clones VHDL (precisos em ciclo) dos processadores ATmega128, MSP430 e Cortex M0+ e simulam o uso de tais curvas. Destaca-se que o processador ARM alcança a melhor eficiência energética e tempo de execução enquanto o MSP430 ocupa a menor área em silício e demanda a menor potência. Por fim, deve-se mencionar que o estado da arte em termos de velocidade encontra-se no trabalho publicado por~\cite{Liu2}, o qual, embora não utilize curvas padronizadas, afirma trabalhar sobre um corpo finito mais compatível com outras implementações de ECC.

\section{Discussão}

A julgar pela literatura, há duas possibilidades abertas para um trabalho sobre o uso energeticamente eficiente de memória em algoritmos baseados em curvas elípticas: 1)Criptografia em dispositivos pessoais móveis (que utilizam processadores com caches, e.g. ARMv7/ARMv8); 2) Criptografia em redes de sensores (que utilizam microcontroladores sem caches, e.g. ATMega). A segunda opção tem foco na codificação eficiente dos algoritmos e no uso de scratchpads. O desafio está na viabilidade das curvas elípticas quando se usam pequenos processadores, sobretudo em face dos requisitos da Internet of Things. Por outro lado, a segunda opção abre a possibilidade de investigar técnicas de compilação para otimização do uso energeticamente eficiente do subsistema de memória. O desafio reside em se reduzir o consumo em memória para algoritmos que possuem uma taxa de faltas já bastante pequena quando comparada à observada para os algoritmos simétricos. Este trabalho adota a primeira opção, em função do interesse em técnicas de compilação para otimização do uso de memória e também porque é para a segunda opção que se dispõe, no momento, de infraestrutura experimental adequada.

Ao se fazer esta opção, os resultados da Figura 7 sugerem que este trabalho tenha seu foco na otimização da cache de instruções, devido ao seu maior impacto potencial na redução do consumo energético em memória principal.

%\chapter{Experimentos realizados}
%\label{ch:experimentos}
%\chapter{Conclusões e trabalhos futuros}
%\label{ch:conclusao}



\bibliographystyle{ufscThesis/ufsc-alf}
\bibliography{bibliografia}

\end{document}
